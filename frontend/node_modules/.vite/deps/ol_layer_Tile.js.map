{
  "version": 3,
  "sources": ["../../ol/layer/TileProperty.js", "../../ol/layer/BaseTile.js", "../../ol/DataTile.js", "../../ol/structs/LRUCache.js", "../../ol/vec/mat4.js", "../../ol/webgl/Canvas.js", "../../ol/reproj/glreproj.js", "../../ol/reproj/DataTile.js", "../../ol/renderer/canvas/TileLayer.js", "../../ol/layer/Tile.js"],
  "sourcesContent": ["/**\r\n * @module ol/layer/TileProperty\r\n */\r\n\r\n/**\r\n * @enum {string}\r\n */\r\nexport default {\r\n  PRELOAD: 'preload',\r\n  USE_INTERIM_TILES_ON_ERROR: 'useInterimTilesOnError',\r\n};\r\n", "/**\r\n * @module ol/layer/BaseTile\r\n */\r\nimport Layer from './Layer.js';\r\nimport TileProperty from './TileProperty.js';\r\n\r\n/***\r\n * @template Return\r\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\r\n *   import(\"../Observable\").OnSignature<import(\"./Base\").BaseLayerObjectEventTypes|\r\n *     import(\"./Layer.js\").LayerEventType|'change:preload'|'change:useInterimTilesOnError', import(\"../Object\").ObjectEvent, Return> &\r\n *   import(\"../Observable\").OnSignature<import(\"../render/EventType\").LayerRenderEventTypes, import(\"../render/Event\").default, Return> &\r\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"./Base\").BaseLayerObjectEventTypes|\r\n *   import(\"./Layer.js\").LayerEventType|'change:preload'|'change:useInterimTilesOnError'|import(\"../render/EventType\").LayerRenderEventTypes, Return>} BaseTileLayerOnSignature\r\n */\r\n\r\n/**\r\n * @template {import(\"../source/Tile.js\").default} TileSourceType\r\n * @typedef {Object} Options\r\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\r\n * @property {number} [opacity=1] Opacity (0, 1).\r\n * @property {boolean} [visible=true] Visibility.\r\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\r\n * rendered outside of this extent.\r\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\r\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\r\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\r\n * method was used.\r\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\r\n * visible.\r\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\r\n * be visible.\r\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\r\n * visible.\r\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\r\n * be visible.\r\n * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`\r\n * means no preloading.\r\n * @property {TileSourceType} [source] Source for this layer.\r\n * @property {import(\"../Map.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\r\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\r\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\r\n * use {@link import(\"../Map.js\").default#addLayer map.addLayer()}.\r\n * @property {import(\"./Base.js\").BackgroundColor} [background] Background color for the layer. If not specified, no background\r\n * will be rendered.\r\n * @property {boolean} [useInterimTilesOnError=true] Deprecated.  Use interim tiles on error.\r\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\r\n * @property {number} [cacheSize=512] The internal tile cache size.  This needs to be large enough to render\r\n * two zoom levels worth of tiles.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * For layer sources that provide pre-rendered, tiled images in grids that are\r\n * organized by zoom levels for specific resolutions.\r\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\r\n * property on the layer object; for example, setting `title: 'My Title'` in the\r\n * options means that `title` is observable, and has get/set accessors.\r\n *\r\n * @template {import(\"../source/Tile.js\").default} TileSourceType\r\n * @template {import(\"../renderer/Layer.js\").default} RendererType\r\n * @extends {Layer<TileSourceType, RendererType>}\r\n * @api\r\n */\r\nclass BaseTileLayer extends Layer {\r\n  /**\r\n   * @param {Options<TileSourceType>} [options] Tile layer options.\r\n   */\r\n  constructor(options) {\r\n    options = options ? options : {};\r\n\r\n    const baseOptions = Object.assign({}, options);\r\n\r\n    const cacheSize = options.cacheSize;\r\n    delete options.cacheSize;\r\n\r\n    delete baseOptions.preload;\r\n    delete baseOptions.useInterimTilesOnError;\r\n    super(baseOptions);\r\n\r\n    /***\r\n     * @type {BaseTileLayerOnSignature<import(\"../events\").EventsKey>}\r\n     */\r\n    this.on;\r\n\r\n    /***\r\n     * @type {BaseTileLayerOnSignature<import(\"../events\").EventsKey>}\r\n     */\r\n    this.once;\r\n\r\n    /***\r\n     * @type {BaseTileLayerOnSignature<void>}\r\n     */\r\n    this.un;\r\n\r\n    /**\r\n     * @type {number|undefined}\r\n     * @private\r\n     */\r\n    this.cacheSize_ = cacheSize;\r\n\r\n    this.setPreload(options.preload !== undefined ? options.preload : 0);\r\n    this.setUseInterimTilesOnError(\r\n      options.useInterimTilesOnError !== undefined\r\n        ? options.useInterimTilesOnError\r\n        : true,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @return {number|undefined} The suggested cache size\r\n   * @protected\r\n   */\r\n  getCacheSize() {\r\n    return this.cacheSize_;\r\n  }\r\n\r\n  /**\r\n   * Return the level as number to which we will preload tiles up to.\r\n   * @return {number} The level to preload tiles up to.\r\n   * @observable\r\n   * @api\r\n   */\r\n  getPreload() {\r\n    return /** @type {number} */ (this.get(TileProperty.PRELOAD));\r\n  }\r\n\r\n  /**\r\n   * Set the level as number to which we will preload tiles up to.\r\n   * @param {number} preload The level to preload tiles up to.\r\n   * @observable\r\n   * @api\r\n   */\r\n  setPreload(preload) {\r\n    this.set(TileProperty.PRELOAD, preload);\r\n  }\r\n\r\n  /**\r\n   * Deprecated.  Whether we use interim tiles on error.\r\n   * @return {boolean} Use interim tiles on error.\r\n   * @observable\r\n   * @api\r\n   */\r\n  getUseInterimTilesOnError() {\r\n    return /** @type {boolean} */ (\r\n      this.get(TileProperty.USE_INTERIM_TILES_ON_ERROR)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Deprecated.  Set whether we use interim tiles on error.\r\n   * @param {boolean} useInterimTilesOnError Use interim tiles on error.\r\n   * @observable\r\n   * @api\r\n   */\r\n  setUseInterimTilesOnError(useInterimTilesOnError) {\r\n    this.set(TileProperty.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);\r\n  }\r\n\r\n  /**\r\n   * Get data for a pixel location.  The return type depends on the source data.  For image tiles,\r\n   * a four element RGBA array will be returned.  For data tiles, the array length will match the\r\n   * number of bands in the dataset.  For requests outside the layer extent, `null` will be returned.\r\n   * Data for a image tiles can only be retrieved if the source's `crossOrigin` property is set.\r\n   *\r\n   * ```js\r\n   * // display layer data on every pointer move\r\n   * map.on('pointermove', (event) => {\r\n   *   console.log(layer.getData(event.pixel));\r\n   * });\r\n   * ```\r\n   * @param {import(\"../pixel\").Pixel} pixel Pixel.\r\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\r\n   * @api\r\n   * @override\r\n   */\r\n  getData(pixel) {\r\n    return super.getData(pixel);\r\n  }\r\n}\r\n\r\nexport default BaseTileLayer;\r\n", "/**\r\n * @module ol/DataTile\r\n */\r\nimport Tile from './Tile.js';\r\nimport TileState from './TileState.js';\r\nimport {createCanvasContext2D} from './dom.js';\r\n\r\n/**\r\n * @typedef {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|ImageBitmap} ImageLike\r\n */\r\n\r\n/**\r\n * @typedef {Uint8Array|Uint8ClampedArray|Float32Array|DataView} ArrayLike\r\n */\r\n\r\n/**\r\n * Data that can be used with a DataTile.\r\n * @typedef {ArrayLike|ImageLike} Data\r\n */\r\n\r\n/**\r\n * @param {Data} data Tile data.\r\n * @return {ImageLike|null} The image-like data.\r\n */\r\nexport function asImageLike(data) {\r\n  return data instanceof Image ||\r\n    data instanceof HTMLCanvasElement ||\r\n    data instanceof HTMLVideoElement ||\r\n    data instanceof ImageBitmap\r\n    ? data\r\n    : null;\r\n}\r\n\r\n/**\r\n * @param {Data} data Tile data.\r\n * @return {ArrayLike|null} The array-like data.\r\n */\r\nexport function asArrayLike(data) {\r\n  return data instanceof Uint8Array ||\r\n    data instanceof Uint8ClampedArray ||\r\n    data instanceof Float32Array ||\r\n    data instanceof DataView\r\n    ? data\r\n    : null;\r\n}\r\n\r\n/**\r\n * This is set as the cancellation reason when a tile is disposed.\r\n */\r\nexport const disposedError = new Error('disposed');\r\n\r\n/**\r\n * @type {CanvasRenderingContext2D|null}\r\n */\r\nlet sharedContext = null;\r\n\r\n/**\r\n * @param {ImageLike} image The image.\r\n * @return {Uint8ClampedArray} The data.\r\n */\r\nexport function toArray(image) {\r\n  if (!sharedContext) {\r\n    sharedContext = createCanvasContext2D(\r\n      image.width,\r\n      image.height,\r\n      undefined,\r\n      {willReadFrequently: true},\r\n    );\r\n  }\r\n  const canvas = sharedContext.canvas;\r\n  const width = image.width;\r\n  if (canvas.width !== width) {\r\n    canvas.width = width;\r\n  }\r\n  const height = image.height;\r\n  if (canvas.height !== height) {\r\n    canvas.height = height;\r\n  }\r\n  sharedContext.clearRect(0, 0, width, height);\r\n  sharedContext.drawImage(image, 0, 0);\r\n  return sharedContext.getImageData(0, 0, width, height).data;\r\n}\r\n\r\n/**\r\n * @type {import('./size.js').Size}\r\n */\r\nconst defaultSize = [256, 256];\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\r\n * @property {function(): Promise<Data>} loader Data loader.  For loaders that generate images,\r\n * the promise should not resolve until the image is loaded.\r\n * @property {number} [transition=250] A duration for tile opacity\r\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\r\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\r\n * the nearest neighbor is used when resampling.\r\n * @property {import('./size.js').Size} [size=[256, 256]] Tile size.\r\n * @property {AbortController} [controller] An abort controller.\r\n * @api\r\n */\r\n\r\nclass DataTile extends Tile {\r\n  /**\r\n   * @param {Options} options Tile options.\r\n   */\r\n  constructor(options) {\r\n    const state = TileState.IDLE;\r\n\r\n    super(options.tileCoord, state, {\r\n      transition: options.transition,\r\n      interpolate: options.interpolate,\r\n    });\r\n\r\n    /**\r\n     * @type {function(): Promise<Data>}\r\n     * @private\r\n     */\r\n    this.loader_ = options.loader;\r\n\r\n    /**\r\n     * @type {Data}\r\n     * @private\r\n     */\r\n    this.data_ = null;\r\n\r\n    /**\r\n     * @type {Error}\r\n     * @private\r\n     */\r\n    this.error_ = null;\r\n\r\n    /**\r\n     * @type {import('./size.js').Size|null}\r\n     * @private\r\n     */\r\n    this.size_ = options.size || null;\r\n\r\n    /**\r\n     * @type {AbortController|null}\r\n     * @private\r\n     */\r\n    this.controller_ = options.controller || null;\r\n  }\r\n\r\n  /**\r\n   * Get the tile size.\r\n   * @return {import('./size.js').Size} Tile size.\r\n   */\r\n  getSize() {\r\n    if (this.size_) {\r\n      return this.size_;\r\n    }\r\n    const imageData = asImageLike(this.data_);\r\n    if (imageData) {\r\n      return [imageData.width, imageData.height];\r\n    }\r\n    return defaultSize;\r\n  }\r\n\r\n  /**\r\n   * Get the data for the tile.\r\n   * @return {Data} Tile data.\r\n   * @api\r\n   */\r\n  getData() {\r\n    return this.data_;\r\n  }\r\n\r\n  /**\r\n   * Get any loading error.\r\n   * @return {Error} Loading error.\r\n   * @api\r\n   */\r\n  getError() {\r\n    return this.error_;\r\n  }\r\n\r\n  /**\r\n   * Load the tile data.\r\n   * @api\r\n   * @override\r\n   */\r\n  load() {\r\n    if (this.state !== TileState.IDLE && this.state !== TileState.ERROR) {\r\n      return;\r\n    }\r\n    this.state = TileState.LOADING;\r\n    this.changed();\r\n\r\n    const self = this;\r\n    this.loader_()\r\n      .then(function (data) {\r\n        self.data_ = data;\r\n        self.state = TileState.LOADED;\r\n        self.changed();\r\n      })\r\n      .catch(function (error) {\r\n        self.error_ = error;\r\n        self.state = TileState.ERROR;\r\n        self.changed();\r\n      });\r\n  }\r\n\r\n  /**\r\n   * Clean up.\r\n   * @override\r\n   */\r\n  disposeInternal() {\r\n    if (this.controller_) {\r\n      this.controller_.abort(disposedError);\r\n      this.controller_ = null;\r\n    }\r\n    super.disposeInternal();\r\n  }\r\n}\r\n\r\nexport default DataTile;\r\n", "/**\r\n * @module ol/structs/LRUCache\r\n */\r\n\r\nimport Disposable from '../Disposable.js';\r\nimport {assert} from '../asserts.js';\r\n\r\n/**\r\n * @typedef {Object} Entry\r\n * @property {string} key_ Key.\r\n * @property {Entry|null} newer Newer.\r\n * @property {Entry|null} older Older.\r\n * @property {*} value_ Value.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Implements a Least-Recently-Used cache where the keys do not conflict with\r\n * Object's properties (e.g. 'hasOwnProperty' is not allowed as a key). Expiring\r\n * items from the cache is the responsibility of the user.\r\n *\r\n * @fires import(\"../events/Event.js\").default\r\n * @template T\r\n */\r\nclass LRUCache {\r\n  /**\r\n   * @param {number} [highWaterMark] High water mark.\r\n   */\r\n  constructor(highWaterMark) {\r\n    /**\r\n     * Desired max cache size after expireCache(). If set to 0, no cache entries\r\n     * will be pruned at all.\r\n     * @type {number}\r\n     */\r\n    this.highWaterMark = highWaterMark !== undefined ? highWaterMark : 2048;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.count_ = 0;\r\n\r\n    /**\r\n     * @private\r\n     * @type {!Object<string, Entry>}\r\n     */\r\n    this.entries_ = {};\r\n\r\n    /**\r\n     * @private\r\n     * @type {?Entry}\r\n     */\r\n    this.oldest_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {?Entry}\r\n     */\r\n    this.newest_ = null;\r\n  }\r\n\r\n  deleteOldest() {\r\n    const entry = this.pop();\r\n    if (entry instanceof Disposable) {\r\n      entry.dispose();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @return {boolean} Can expire cache.\r\n   */\r\n  canExpireCache() {\r\n    return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;\r\n  }\r\n\r\n  /**\r\n   * Expire the cache. When the cache entry is a {@link module:ol/Disposable~Disposable},\r\n   * the entry will be disposed.\r\n   * @param {!Object<string, boolean>} [keep] Keys to keep. To be implemented by subclasses.\r\n   */\r\n  expireCache(keep) {\r\n    while (this.canExpireCache()) {\r\n      this.deleteOldest();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * FIXME empty description for jsdoc\r\n   */\r\n  clear() {\r\n    while (this.oldest_) {\r\n      this.deleteOldest();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {string} key Key.\r\n   * @return {boolean} Contains key.\r\n   */\r\n  containsKey(key) {\r\n    return this.entries_.hasOwnProperty(key);\r\n  }\r\n\r\n  /**\r\n   * @param {function(T, string, LRUCache<T>): ?} f The function\r\n   *     to call for every entry from the oldest to the newer. This function takes\r\n   *     3 arguments (the entry value, the entry key and the LRUCache object).\r\n   *     The return value is ignored.\r\n   */\r\n  forEach(f) {\r\n    let entry = this.oldest_;\r\n    while (entry) {\r\n      f(entry.value_, entry.key_, this);\r\n      entry = entry.newer;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {string} key Key.\r\n   * @param {*} [options] Options (reserved for subclasses).\r\n   * @return {T} Value.\r\n   */\r\n  get(key, options) {\r\n    const entry = this.entries_[key];\r\n    assert(\r\n      entry !== undefined,\r\n      'Tried to get a value for a key that does not exist in the cache',\r\n    );\r\n    if (entry === this.newest_) {\r\n      return entry.value_;\r\n    }\r\n    if (entry === this.oldest_) {\r\n      this.oldest_ = /** @type {Entry} */ (this.oldest_.newer);\r\n      this.oldest_.older = null;\r\n    } else {\r\n      entry.newer.older = entry.older;\r\n      entry.older.newer = entry.newer;\r\n    }\r\n    entry.newer = null;\r\n    entry.older = this.newest_;\r\n    this.newest_.newer = entry;\r\n    this.newest_ = entry;\r\n    return entry.value_;\r\n  }\r\n\r\n  /**\r\n   * Remove an entry from the cache.\r\n   * @param {string} key The entry key.\r\n   * @return {T} The removed entry.\r\n   */\r\n  remove(key) {\r\n    const entry = this.entries_[key];\r\n    assert(\r\n      entry !== undefined,\r\n      'Tried to get a value for a key that does not exist in the cache',\r\n    );\r\n    if (entry === this.newest_) {\r\n      this.newest_ = /** @type {Entry} */ (entry.older);\r\n      if (this.newest_) {\r\n        this.newest_.newer = null;\r\n      }\r\n    } else if (entry === this.oldest_) {\r\n      this.oldest_ = /** @type {Entry} */ (entry.newer);\r\n      if (this.oldest_) {\r\n        this.oldest_.older = null;\r\n      }\r\n    } else {\r\n      entry.newer.older = entry.older;\r\n      entry.older.newer = entry.newer;\r\n    }\r\n    delete this.entries_[key];\r\n    --this.count_;\r\n    return entry.value_;\r\n  }\r\n\r\n  /**\r\n   * @return {number} Count.\r\n   */\r\n  getCount() {\r\n    return this.count_;\r\n  }\r\n\r\n  /**\r\n   * @return {Array<string>} Keys.\r\n   */\r\n  getKeys() {\r\n    const keys = new Array(this.count_);\r\n    let i = 0;\r\n    let entry;\r\n    for (entry = this.newest_; entry; entry = entry.older) {\r\n      keys[i++] = entry.key_;\r\n    }\r\n    return keys;\r\n  }\r\n\r\n  /**\r\n   * @return {Array<T>} Values.\r\n   */\r\n  getValues() {\r\n    const values = new Array(this.count_);\r\n    let i = 0;\r\n    let entry;\r\n    for (entry = this.newest_; entry; entry = entry.older) {\r\n      values[i++] = entry.value_;\r\n    }\r\n    return values;\r\n  }\r\n\r\n  /**\r\n   * @return {T} Last value.\r\n   */\r\n  peekLast() {\r\n    return this.oldest_.value_;\r\n  }\r\n\r\n  /**\r\n   * @return {string} Last key.\r\n   */\r\n  peekLastKey() {\r\n    return this.oldest_.key_;\r\n  }\r\n\r\n  /**\r\n   * Get the key of the newest item in the cache.  Throws if the cache is empty.\r\n   * @return {string} The newest key.\r\n   */\r\n  peekFirstKey() {\r\n    return this.newest_.key_;\r\n  }\r\n\r\n  /**\r\n   * Return an entry without updating least recently used time.\r\n   * @param {string} key Key.\r\n   * @return {T|undefined} Value.\r\n   */\r\n  peek(key) {\r\n    return this.entries_[key]?.value_;\r\n  }\r\n\r\n  /**\r\n   * @return {T} value Value.\r\n   */\r\n  pop() {\r\n    const entry = this.oldest_;\r\n    delete this.entries_[entry.key_];\r\n    if (entry.newer) {\r\n      entry.newer.older = null;\r\n    }\r\n    this.oldest_ = /** @type {Entry} */ (entry.newer);\r\n    if (!this.oldest_) {\r\n      this.newest_ = null;\r\n    }\r\n    --this.count_;\r\n    return entry.value_;\r\n  }\r\n\r\n  /**\r\n   * @param {string} key Key.\r\n   * @param {T} value Value.\r\n   */\r\n  replace(key, value) {\r\n    this.get(key); // update `newest_`\r\n    this.entries_[key].value_ = value;\r\n  }\r\n\r\n  /**\r\n   * @param {string} key Key.\r\n   * @param {T} value Value.\r\n   */\r\n  set(key, value) {\r\n    assert(\r\n      !(key in this.entries_),\r\n      'Tried to set a value for a key that is used already',\r\n    );\r\n    const entry = {\r\n      key_: key,\r\n      newer: null,\r\n      older: this.newest_,\r\n      value_: value,\r\n    };\r\n    if (!this.newest_) {\r\n      this.oldest_ = entry;\r\n    } else {\r\n      this.newest_.newer = entry;\r\n    }\r\n    this.newest_ = entry;\r\n    this.entries_[key] = entry;\r\n    ++this.count_;\r\n  }\r\n\r\n  /**\r\n   * Set a maximum number of entries for the cache.\r\n   * @param {number} size Cache size.\r\n   * @api\r\n   */\r\n  setSize(size) {\r\n    this.highWaterMark = size;\r\n  }\r\n}\r\n\r\nexport default LRUCache;\r\n", "/**\r\n * @module ol/vec/mat4\r\n */\r\n\r\n/** @typedef {Array<number>} Mat4 */\r\n\r\n/**\r\n * @return {Mat4} \"4x4 matrix representing a 3D identity transform.\"\r\n */\r\nexport function create() {\r\n  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\r\n}\r\n\r\n/**\r\n * @param {Mat4} mat4 Flattened 4x4 matrix receiving the result.\r\n * @param {import(\"../transform.js\").Transform} transform Transformation matrix.\r\n * @return {Mat4} \"2D transformation matrix as flattened 4x4 matrix.\"\r\n */\r\nexport function fromTransform(mat4, transform) {\r\n  mat4[0] = transform[0];\r\n  mat4[1] = transform[1];\r\n  mat4[4] = transform[2];\r\n  mat4[5] = transform[3];\r\n  mat4[12] = transform[4];\r\n  mat4[13] = transform[5];\r\n  return mat4;\r\n}\r\n\r\n/**\r\n * Generates a orthogonal projection matrix with the given bounds\r\n *\r\n * @param {number} left Left bound of the frustum\r\n * @param {number} right Right bound of the frustum\r\n * @param {number} bottom Bottom bound of the frustum\r\n * @param {number} top Top bound of the frustum\r\n * @param {number} near Near bound of the frustum\r\n * @param {number} far Far bound of the frustum\r\n * @param {Mat4} [out] mat4 frustum matrix will be written into\r\n * @return {Mat4} out\r\n */\r\nexport function orthographic(left, right, bottom, top, near, far, out) {\r\n  out = out ?? create();\r\n  const lr = 1 / (left - right),\r\n    bt = 1 / (bottom - top),\r\n    nf = 1 / (near - far);\r\n  out[0] = -2 * lr;\r\n  out[1] = 0;\r\n  out[2] = 0;\r\n  out[3] = 0;\r\n  out[4] = 0;\r\n  out[5] = -2 * bt;\r\n  out[6] = 0;\r\n  out[7] = 0;\r\n  out[8] = 0;\r\n  out[9] = 0;\r\n  out[10] = 2 * nf;\r\n  out[11] = 0;\r\n  out[12] = (left + right) * lr;\r\n  out[13] = (top + bottom) * bt;\r\n  out[14] = (far + near) * nf;\r\n  out[15] = 1;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Scales the mat4 by the dimensions in the given vec3\r\n *\r\n * @param {Mat4} m The matrix to scale.\r\n * @param {number} x How much to scale in the x direction.\r\n * @param {number} y How much to scale in the y direction.\r\n * @param {number} z How much to scale in the z direction.\r\n * @param {Mat4} [out] The matrix to write to.\r\n * @return {Mat4} out\r\n **/\r\nexport function scale(m, x, y, z, out) {\r\n  out = out ?? create();\r\n  out[0] = m[0] * x;\r\n  out[1] = m[1] * x;\r\n  out[2] = m[2] * x;\r\n  out[3] = m[3] * x;\r\n  out[4] = m[4] * y;\r\n  out[5] = m[5] * y;\r\n  out[6] = m[6] * y;\r\n  out[7] = m[7] * y;\r\n  out[8] = m[8] * z;\r\n  out[9] = m[9] * z;\r\n  out[10] = m[10] * z;\r\n  out[11] = m[11] * z;\r\n  out[12] = m[12];\r\n  out[13] = m[13];\r\n  out[14] = m[14];\r\n  out[15] = m[15];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Translate a matrix.\r\n *\r\n * @param {Mat4} m the matrix to translate\r\n * @param {number} x How much to translate in the x direction.\r\n * @param {number} y How much to translate in the y direction.\r\n * @param {number} z How much to translate in the z direction.\r\n * @param {Mat4} [out] the receiving matrix\r\n * @return {Mat4} out\r\n */\r\nexport function translate(m, x, y, z, out) {\r\n  out = out ?? create();\r\n  let a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23;\r\n\r\n  if (m === out) {\r\n    out[12] = m[0] * x + m[4] * y + m[8] * z + m[12];\r\n    out[13] = m[1] * x + m[5] * y + m[9] * z + m[13];\r\n    out[14] = m[2] * x + m[6] * y + m[10] * z + m[14];\r\n    out[15] = m[3] * x + m[7] * y + m[11] * z + m[15];\r\n  } else {\r\n    a00 = m[0];\r\n    a01 = m[1];\r\n    a02 = m[2];\r\n    a03 = m[3];\r\n    a10 = m[4];\r\n    a11 = m[5];\r\n    a12 = m[6];\r\n    a13 = m[7];\r\n    a20 = m[8];\r\n    a21 = m[9];\r\n    a22 = m[10];\r\n    a23 = m[11];\r\n\r\n    out[0] = a00;\r\n    out[1] = a01;\r\n    out[2] = a02;\r\n    out[3] = a03;\r\n    out[4] = a10;\r\n    out[5] = a11;\r\n    out[6] = a12;\r\n    out[7] = a13;\r\n    out[8] = a20;\r\n    out[9] = a21;\r\n    out[10] = a22;\r\n    out[11] = a23;\r\n\r\n    out[12] = a00 * x + a10 * y + a20 * z + m[12];\r\n    out[13] = a01 * x + a11 * y + a21 * z + m[13];\r\n    out[14] = a02 * x + a12 * y + a22 * z + m[14];\r\n    out[15] = a03 * x + a13 * y + a23 * z + m[15];\r\n  }\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * @param {number} x x translation.\r\n * @param {number} y y translation.\r\n * @param {number} z z translation.\r\n * @param {Mat4} [out] optional matrix to store result\r\n * @return {Mat4} out\r\n */\r\nexport function translation(x, y, z, out) {\r\n  out = out ?? create();\r\n\r\n  out[0] = 1;\r\n  out[1] = 0;\r\n  out[2] = 0;\r\n  out[3] = 0;\r\n  out[4] = 0;\r\n  out[5] = 1;\r\n  out[6] = 0;\r\n  out[7] = 0;\r\n  out[8] = 0;\r\n  out[9] = 0;\r\n  out[10] = 1;\r\n  out[11] = 0;\r\n  out[12] = x;\r\n  out[13] = y;\r\n  out[14] = z;\r\n  out[15] = 1;\r\n\r\n  return out;\r\n}\r\n", "import * as mat4 from '../vec/mat4.js';\r\n\r\n/**\r\n * @module ol/webgl/Canvas\r\n */\r\n\r\nconst VERTEX_SHADER = `\r\n  attribute vec4 a_position;\r\n  attribute vec4 a_texcoord;\r\n\r\n  uniform mat4 u_matrix;\r\n  uniform mat4 u_textureMatrix;\r\n\r\n  varying vec2 v_texcoord;\r\n\r\n  void main() {\r\n    gl_Position = u_matrix * a_position;\r\n    vec2 texcoord = (u_textureMatrix * a_texcoord).xy;\r\n    v_texcoord = texcoord;\r\n  }\r\n`;\r\n\r\nconst FRAGMENT_SHADER = `\r\n  precision mediump float;\r\n\r\n  varying vec2 v_texcoord;\r\n\r\n  uniform sampler2D u_texture;\r\n\r\n  void main() {\r\n    if (\r\n      v_texcoord.x < 0.0 ||\r\n      v_texcoord.y < 0.0 ||\r\n      v_texcoord.x > 1.0 ||\r\n      v_texcoord.y > 1.0\r\n    ) {\r\n      discard;\r\n    }\r\n    gl_FragColor = texture2D(u_texture, v_texcoord);\r\n  }\r\n`;\r\n\r\n/** @typedef {import(\"../transform.js\").Transform} Matrix */\r\n\r\n/**\r\n * Canvas-like operations implemented in webgl.\r\n */\r\nexport class Canvas {\r\n  /**\r\n   * @param {WebGLRenderingContext} gl Context to render in.\r\n   */\r\n  constructor(gl) {\r\n    /**\r\n     * @private\r\n     * @type {WebGLRenderingContext}\r\n     */\r\n    this.gl_ = gl;\r\n\r\n    /**\r\n     * @private\r\n     * @type {WebGLProgram}\r\n     */\r\n    this.program_ = createProgram(gl, FRAGMENT_SHADER, VERTEX_SHADER);\r\n\r\n    this.positionLocation = gl.getAttribLocation(this.program_, 'a_position');\r\n    this.texcoordLocation = gl.getAttribLocation(this.program_, 'a_texcoord');\r\n\r\n    this.matrixLocation = gl.getUniformLocation(this.program_, 'u_matrix');\r\n    this.textureMatrixLocation = gl.getUniformLocation(\r\n      this.program_,\r\n      'u_textureMatrix',\r\n    );\r\n    this.textureLocation = gl.getUniformLocation(this.program_, 'u_texture');\r\n\r\n    this.positionBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);\r\n\r\n    this.positions = [0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1];\r\n    gl.bufferData(\r\n      gl.ARRAY_BUFFER,\r\n      new Float32Array(this.positions),\r\n      gl.STATIC_DRAW,\r\n    );\r\n\r\n    this.texcoordBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.texcoordBuffer);\r\n\r\n    this.texcoords = [0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1];\r\n    gl.bufferData(\r\n      gl.ARRAY_BUFFER,\r\n      new Float32Array(this.texcoords),\r\n      gl.STATIC_DRAW,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * 2dContext drawImage call implemented in webgl.\r\n   * Unlike images, textures do not have a width and height associated\r\n   * with them so we'll pass in the width and height of the texture.\r\n   *\r\n   * @param {WebGLTexture} tex Image to draw.\r\n   * @param {number} texWidth Image width.\r\n   * @param {number} texHeight Image height.\r\n   * @param {number} srcX Top-left x-point to read src image.\r\n   * @param {number} srcY Top-left y-point to read src image.\r\n   * @param {number} [srcWidth] Width of source to read.\r\n   * @param {number} [srcHeight] Height of source to read.\r\n   * @param {number} [dstX] Top-left x-point of destination.\r\n   * @param {number} [dstY] Top-left y-point of destination.\r\n   * @param {number} [dstWidth] Width of written image in destination.\r\n   * @param {number} [dstHeight] Height of written image in destination.\r\n   * @param {number} [width] Width of canvas.\r\n   * @param {number} [height] Height of canvas.\r\n   */\r\n  drawImage(\r\n    tex,\r\n    texWidth,\r\n    texHeight,\r\n    srcX,\r\n    srcY,\r\n    srcWidth,\r\n    srcHeight,\r\n    dstX,\r\n    dstY,\r\n    dstWidth,\r\n    dstHeight,\r\n    width,\r\n    height,\r\n  ) {\r\n    const gl = this.gl_;\r\n\r\n    if (dstX === undefined) {\r\n      dstX = srcX;\r\n    }\r\n    if (dstY === undefined) {\r\n      dstY = srcY;\r\n    }\r\n    if (srcWidth === undefined) {\r\n      srcWidth = texWidth;\r\n    }\r\n    if (srcHeight === undefined) {\r\n      srcHeight = texHeight;\r\n    }\r\n    if (dstWidth === undefined) {\r\n      dstWidth = srcWidth;\r\n    }\r\n    if (dstHeight === undefined) {\r\n      dstHeight = srcHeight;\r\n    }\r\n    if (width === undefined) {\r\n      width = gl.canvas.width;\r\n    }\r\n    if (height === undefined) {\r\n      height = gl.canvas.height;\r\n    }\r\n\r\n    gl.bindTexture(gl.TEXTURE_2D, tex);\r\n\r\n    gl.useProgram(this.program_);\r\n\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);\r\n    gl.enableVertexAttribArray(this.positionLocation);\r\n    gl.vertexAttribPointer(this.positionLocation, 2, gl.FLOAT, false, 0, 0);\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.texcoordBuffer);\r\n    gl.enableVertexAttribArray(this.texcoordLocation);\r\n    gl.vertexAttribPointer(this.texcoordLocation, 2, gl.FLOAT, false, 0, 0);\r\n\r\n    // matrix for converting pixels to clip space\r\n    let matrix = mat4.orthographic(0, width, 0, height, -1, 1);\r\n    matrix = mat4.translate(matrix, dstX, dstY, 0);\r\n    matrix = mat4.scale(matrix, dstWidth, dstHeight, 1);\r\n    gl.uniformMatrix4fv(this.matrixLocation, false, matrix);\r\n\r\n    let texMatrix = mat4.translation(srcX / texWidth, srcY / texHeight, 0);\r\n    texMatrix = mat4.scale(\r\n      texMatrix,\r\n      srcWidth / texWidth,\r\n      srcHeight / texHeight,\r\n      1,\r\n    );\r\n\r\n    gl.uniformMatrix4fv(this.textureMatrixLocation, false, texMatrix);\r\n    gl.uniform1i(this.textureLocation, 0);\r\n    gl.drawArrays(gl.TRIANGLES, 0, this.positions.length / 2);\r\n  }\r\n}\r\n\r\n/**\r\n * @param {WebGLRenderingContext} gl Rendering Context.\r\n * @param {GLenum} type Type of shader.\r\n * @param {string} source source of shader.\r\n * @return {WebGLShader} [progam] The program.\r\n */\r\nfunction createShader(gl, type, source) {\r\n  const shader = gl.createShader(type);\r\n\r\n  if (shader === null) {\r\n    throw new Error('Shader compilation failed');\r\n  }\r\n\r\n  gl.shaderSource(shader, source);\r\n\r\n  gl.compileShader(shader);\r\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\r\n    const log = gl.getShaderInfoLog(shader);\r\n    if (log === null) {\r\n      throw new Error('Shader info log creation failed');\r\n    }\r\n    throw new Error(log);\r\n  }\r\n\r\n  return shader;\r\n}\r\n\r\n/**\r\n * @param {WebGLRenderingContext} gl Rendering Context.\r\n * @param {string} fragmentSource Fragment shader source.\r\n * @param {string} vertexSource Vertex shader source.\r\n * @return {WebGLProgram} [progam] The program.\r\n */\r\nexport function createProgram(gl, fragmentSource, vertexSource) {\r\n  const program = gl.createProgram();\r\n\r\n  const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexSource);\r\n  const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentSource);\r\n  if (program === null) {\r\n    throw new Error('Program creation failed');\r\n  }\r\n\r\n  gl.attachShader(program, vertexShader);\r\n  gl.attachShader(program, fragmentShader);\r\n\r\n  gl.linkProgram(program);\r\n  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\r\n    const log = gl.getProgramInfoLog(program);\r\n    if (log === null) {\r\n      throw new Error('Program info log creation failed');\r\n    }\r\n    throw new Error();\r\n  }\r\n  return program;\r\n}\r\n", "/**\r\n * @module ol/reproj/glreproj\r\n */\r\nimport * as mat4 from '../vec/mat4.js';\r\nimport {WORKER_OFFSCREEN_CANVAS} from '../has.js';\r\nimport {Canvas as WebGLCanvas, createProgram} from '../webgl/Canvas.js';\r\nimport {\r\n  createEmpty,\r\n  extend,\r\n  getHeight,\r\n  getTopLeft,\r\n  getWidth,\r\n} from '../extent.js';\r\n\r\nconst EDGE_VERTEX_SHADER = `\r\n  attribute vec4 a_position;\r\n\r\n  uniform mat4 u_matrix;\r\n\r\n  void main() {\r\n     gl_Position = u_matrix * a_position;\r\n  }\r\n`;\r\nconst EDGE_FRAGMENT_SHADER = `\r\n  precision mediump float;\r\n\r\n  uniform vec4 u_val;\r\n  void main() {\r\n     gl_FragColor = u_val;\r\n  }\r\n`;\r\n\r\nconst TRIANGLE_VERTEX_SHADER = `\r\n  attribute vec4 a_position;\r\n  attribute vec2 a_texcoord;\r\n\r\n  varying vec2 v_texcoord;\r\n\r\n  uniform mat4 u_matrix;\r\n\r\n  void main() {\r\n     gl_Position = u_matrix * a_position;\r\n     v_texcoord = a_texcoord;\r\n  }\r\n`;\r\nconst TRIANGLE_FRAGMENT_SHADER = `\r\n  precision mediump float;\r\n\r\n  varying vec2 v_texcoord;\r\n\r\n  uniform sampler2D u_texture;\r\n\r\n  void main() {\r\n    if (v_texcoord.x < 0.0 || v_texcoord.x > 1.0 || v_texcoord.y < 0.0 || v_texcoord.y > 1.0) {\r\n      discard;\r\n    }\r\n    gl_FragColor = texture2D(u_texture, v_texcoord);\r\n  }\r\n`;\r\n\r\n/**\r\n * Create an html canvas element and returns its webgl context.\r\n * @param {number} [width] Canvas width.\r\n * @param {number} [height] Canvas height.\r\n * @param {Array<HTMLCanvasElement | OffscreenCanvas>} [canvasPool] Canvas pool to take existing canvas from.\r\n * @param {WebGLContextAttributes} [settings] CanvasRenderingContext2DSettings\r\n * @return {WebGLRenderingContext} The context.\r\n */\r\nexport function createCanvasContextWebGL(width, height, canvasPool, settings) {\r\n  /** @type {HTMLCanvasElement|OffscreenCanvas} */\r\n  let canvas;\r\n  if (canvasPool && canvasPool.length) {\r\n    canvas = /** @type {HTMLCanvasElement} */ (canvasPool.shift());\r\n  } else if (WORKER_OFFSCREEN_CANVAS) {\r\n    canvas = new OffscreenCanvas(width || 300, height || 300);\r\n  } else {\r\n    canvas = document.createElement('canvas');\r\n  }\r\n  if (width) {\r\n    canvas.width = width;\r\n  }\r\n  if (height) {\r\n    canvas.height = height;\r\n  }\r\n  //FIXME Allow OffscreenCanvasRenderingContext2D as return type\r\n  return /** @type {WebGLRenderingContext} */ (\r\n    canvas.getContext('webgl', settings)\r\n  );\r\n}\r\n\r\n/**\r\n * Releases canvas memory to avoid exceeding memory limits in Safari.\r\n * See https://pqina.nl/blog/total-canvas-memory-use-exceeds-the-maximum-limit/\r\n * @param {WebGLRenderingContext} gl Context.\r\n */\r\nexport function releaseGLCanvas(gl) {\r\n  const canvas = gl.canvas;\r\n  canvas.width = 1;\r\n  canvas.height = 1;\r\n  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);\r\n}\r\n\r\n/**\r\n * @type {Array<HTMLCanvasElement | OffscreenCanvas>}\r\n */\r\nexport const canvasGLPool = [];\r\n\r\n/**\r\n * @typedef {Object} ImageExtent\r\n * @property {import(\"../extent.js\").Extent} extent Extent.\r\n * @property {import(\"../extent.js\").Extent} [clipExtent] Clip extent.\r\n * @property {WebGLTexture} texture Texture.\r\n * @property {number} width Width of texture.\r\n * @property {number} height Height of texture.\r\n */\r\n\r\n/**\r\n * Renders the source data into new canvas based on the triangulation.\r\n *\r\n * @param {WebGLRenderingContext} gl the context to render in.\r\n * @param {number} width_ Width of the canvas.\r\n * @param {number} height_ Height of the canvas.\r\n * @param {number} pixelRatio Pixel ratio.\r\n * @param {number} sourceResolution Source resolution.\r\n * @param {number} targetResolution Target resolution.\r\n * @param {import(\"../extent.js\").Extent} targetExtent Target extent (tile).\r\n * @param {import(\"../reproj/Triangulation.js\").default} triangulation Calculated triangulation.\r\n * @param {Array<ImageExtent>} sources Array of sources.\r\n * @param {number} gutter Gutter of the sources.\r\n * @param {number} dataType What kind of data is the textures, must be gl.FLOAT or gl.UNSIGNED_BYTE\r\n * TODO: Allow setting renderEdges value in the data as this is done in \"data-space\".\r\n * @param {boolean | Array<number>} [renderEdges] Render reprojection edges.\r\n * @param {boolean} [interpolate] Use linear interpolation when resampling.\r\n * @param {boolean} [drawSingle] Draw single source images directly without stitchTexture.\r\n * @return {{framebuffer: WebGLFramebuffer, width: number, height: number, texture: WebGLTexture}} Canvas with reprojected data.\r\n */\r\nexport function render(\r\n  gl,\r\n  width_,\r\n  height_,\r\n  pixelRatio,\r\n  sourceResolution,\r\n  targetResolution,\r\n  targetExtent,\r\n  triangulation,\r\n  sources,\r\n  gutter,\r\n  dataType,\r\n  renderEdges,\r\n  interpolate,\r\n  drawSingle,\r\n) {\r\n  const width = Math.round(pixelRatio * width_);\r\n  const height = Math.round(pixelRatio * height_);\r\n  gl.canvas.width = width;\r\n  gl.canvas.height = height;\r\n\r\n  /** @type {WebGLFramebuffer | null} */\r\n  let resultFrameBuffer;\r\n  /** @type {WebGLTexture | null} */\r\n  let resultTexture;\r\n  {\r\n    resultTexture = gl.createTexture();\r\n    gl.bindTexture(gl.TEXTURE_2D, resultTexture);\r\n\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n    if (interpolate) {\r\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n    } else {\r\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\r\n    }\r\n    gl.texImage2D(\r\n      gl.TEXTURE_2D,\r\n      0,\r\n      gl.RGBA,\r\n      width,\r\n      height,\r\n      0,\r\n      gl.RGBA,\r\n      dataType,\r\n      null,\r\n    );\r\n\r\n    resultFrameBuffer = gl.createFramebuffer();\r\n    gl.bindFramebuffer(gl.FRAMEBUFFER, resultFrameBuffer);\r\n    gl.framebufferTexture2D(\r\n      gl.FRAMEBUFFER,\r\n      gl.COLOR_ATTACHMENT0,\r\n      gl.TEXTURE_2D,\r\n      resultTexture,\r\n      0,\r\n    );\r\n  }\r\n\r\n  if (resultFrameBuffer === null) {\r\n    throw new Error('Could not create framebuffer');\r\n  }\r\n  if (resultTexture === null) {\r\n    throw new Error('Could not create texture');\r\n  }\r\n\r\n  if (sources.length === 0) {\r\n    return {\r\n      width,\r\n      height,\r\n      framebuffer: resultFrameBuffer,\r\n      texture: resultTexture,\r\n    };\r\n  }\r\n\r\n  const sourceDataExtent = createEmpty();\r\n  sources.forEach(function (src, i, arr) {\r\n    extend(sourceDataExtent, src.extent);\r\n  });\r\n\r\n  /** @type {WebGLTexture | null} */\r\n  let stitchTexture;\r\n  /** @type {number} */\r\n  let stitchWidth;\r\n  /** @type {number} */\r\n  let stitchHeight;\r\n  const stitchScale = 1 / sourceResolution;\r\n\r\n  if (!drawSingle || sources.length !== 1 || gutter !== 0) {\r\n    stitchTexture = gl.createTexture();\r\n    if (resultTexture === null) {\r\n      throw new Error('Could not create texture');\r\n    }\r\n    stitchWidth = Math.round(getWidth(sourceDataExtent) * stitchScale);\r\n    stitchHeight = Math.round(getHeight(sourceDataExtent) * stitchScale);\r\n\r\n    // Make sure we do not exceed the max texture size by lowering the resolution for this image.\r\n    // https://github.com/openlayers/openlayers/pull/15860#issuecomment-2254123580\r\n    const maxTexSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);\r\n    const largeSide = Math.max(stitchWidth, stitchHeight);\r\n    const scaleFactor = largeSide > maxTexSize ? maxTexSize / largeSide : 1;\r\n    const stitchWidthFixed = Math.round(stitchWidth * scaleFactor);\r\n    const stitchHeightFixed = Math.round(stitchHeight * scaleFactor);\r\n\r\n    gl.bindTexture(gl.TEXTURE_2D, stitchTexture);\r\n\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n    if (interpolate) {\r\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n    } else {\r\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\r\n    }\r\n    gl.texImage2D(\r\n      gl.TEXTURE_2D,\r\n      0,\r\n      gl.RGBA,\r\n      stitchWidthFixed,\r\n      stitchHeightFixed,\r\n      0,\r\n      gl.RGBA,\r\n      dataType,\r\n      null,\r\n    );\r\n\r\n    const fb = gl.createFramebuffer();\r\n    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);\r\n    gl.framebufferTexture2D(\r\n      gl.FRAMEBUFFER,\r\n      gl.COLOR_ATTACHMENT0,\r\n      gl.TEXTURE_2D,\r\n      stitchTexture,\r\n      0,\r\n    );\r\n    const webGLCanvas = new WebGLCanvas(gl);\r\n\r\n    sources.forEach(function (src, i, arr) {\r\n      const xPos =\r\n        (src.extent[0] - sourceDataExtent[0]) * stitchScale * scaleFactor;\r\n      const yPos =\r\n        -(src.extent[3] - sourceDataExtent[3]) * stitchScale * scaleFactor;\r\n      const srcWidth = getWidth(src.extent) * stitchScale * scaleFactor;\r\n      const srcHeight = getHeight(src.extent) * stitchScale * scaleFactor;\r\n      gl.bindFramebuffer(gl.FRAMEBUFFER, fb);\r\n      gl.viewport(0, 0, stitchWidthFixed, stitchHeightFixed);\r\n\r\n      if (src.clipExtent) {\r\n        const xPos =\r\n          (src.clipExtent[0] - sourceDataExtent[0]) * stitchScale * scaleFactor;\r\n        const yPos =\r\n          -(src.clipExtent[3] - sourceDataExtent[3]) *\r\n          stitchScale *\r\n          scaleFactor;\r\n        const width = getWidth(src.clipExtent) * stitchScale * scaleFactor;\r\n        const height = getHeight(src.clipExtent) * stitchScale * scaleFactor;\r\n        gl.enable(gl.SCISSOR_TEST);\r\n        gl.scissor(\r\n          interpolate ? xPos : Math.round(xPos),\r\n          interpolate ? yPos : Math.round(yPos),\r\n          interpolate ? width : Math.round(xPos + width) - Math.round(xPos),\r\n          interpolate ? height : Math.round(yPos + height) - Math.round(yPos),\r\n        );\r\n      }\r\n\r\n      webGLCanvas.drawImage(\r\n        src.texture,\r\n        src.width,\r\n        src.height,\r\n        gutter,\r\n        gutter,\r\n        src.width - 2 * gutter,\r\n        src.height - 2 * gutter,\r\n        interpolate ? xPos : Math.round(xPos),\r\n        interpolate ? yPos : Math.round(yPos),\r\n        interpolate ? srcWidth : Math.round(xPos + srcWidth) - Math.round(xPos),\r\n        interpolate\r\n          ? srcHeight\r\n          : Math.round(yPos + srcHeight) - Math.round(yPos),\r\n        stitchWidthFixed,\r\n        stitchHeightFixed,\r\n      );\r\n\r\n      gl.disable(gl.SCISSOR_TEST);\r\n    });\r\n    gl.deleteFramebuffer(fb);\r\n  } else {\r\n    stitchTexture = sources[0].texture;\r\n    stitchWidth = sources[0].width;\r\n    stitchHeight = sources[0].width;\r\n  }\r\n\r\n  const targetTopLeft = getTopLeft(targetExtent);\r\n  const sourceTopLeft = getTopLeft(sourceDataExtent);\r\n\r\n  const getUVs = (\r\n    /** @type {Array<import(\"../coordinate.js\").Coordinate>} */ target,\r\n  ) => {\r\n    const u0 =\r\n      ((target[0][0] - targetTopLeft[0]) / targetResolution) * pixelRatio;\r\n    const v0 =\r\n      (-(target[0][1] - targetTopLeft[1]) / targetResolution) * pixelRatio;\r\n    const u1 =\r\n      ((target[1][0] - targetTopLeft[0]) / targetResolution) * pixelRatio;\r\n    const v1 =\r\n      (-(target[1][1] - targetTopLeft[1]) / targetResolution) * pixelRatio;\r\n    const u2 =\r\n      ((target[2][0] - targetTopLeft[0]) / targetResolution) * pixelRatio;\r\n    const v2 =\r\n      (-(target[2][1] - targetTopLeft[1]) / targetResolution) * pixelRatio;\r\n    return {u1, v1, u0, v0, u2, v2};\r\n  };\r\n\r\n  gl.bindFramebuffer(gl.FRAMEBUFFER, resultFrameBuffer);\r\n  gl.viewport(0, 0, width, height);\r\n\r\n  // Draw source to reprojtile\r\n  {\r\n    /** @type {Array<number>} */\r\n    const vertices = [];\r\n    /** @type {Array<number>} */\r\n    const texcoords = [];\r\n\r\n    const triProgram = createProgram(\r\n      gl,\r\n      TRIANGLE_FRAGMENT_SHADER,\r\n      TRIANGLE_VERTEX_SHADER,\r\n    );\r\n    gl.useProgram(triProgram);\r\n\r\n    // Bind image\r\n    const textureLocation = gl.getUniformLocation(triProgram, 'u_texture');\r\n    gl.bindTexture(gl.TEXTURE_2D, stitchTexture);\r\n\r\n    // Tell the shader to get the texture from texture unit 0\r\n    gl.uniform1i(textureLocation, 0);\r\n\r\n    // Calculate vert and tex coordinates.\r\n    triangulation.getTriangles().forEach(function (triangle, i, arr) {\r\n      const source = triangle.source;\r\n      const target = triangle.target;\r\n      // Make sure that everything is on pixel boundaries\r\n      const {u1, v1, u0, v0, u2, v2} = getUVs(target);\r\n\r\n      const su0 =\r\n        (source[0][0] - sourceTopLeft[0]) / sourceResolution / stitchWidth;\r\n      const sv0 =\r\n        -(source[0][1] - sourceTopLeft[1]) / sourceResolution / stitchHeight;\r\n      const su1 =\r\n        (source[1][0] - sourceTopLeft[0]) / sourceResolution / stitchWidth;\r\n      const sv1 =\r\n        -(source[1][1] - sourceTopLeft[1]) / sourceResolution / stitchHeight;\r\n      const su2 =\r\n        (source[2][0] - sourceTopLeft[0]) / sourceResolution / stitchWidth;\r\n      const sv2 =\r\n        -(source[2][1] - sourceTopLeft[1]) / sourceResolution / stitchHeight;\r\n\r\n      vertices.push(u1, v1, u0, v0, u2, v2);\r\n      texcoords.push(su1, sv1, su0, sv0, su2, sv2);\r\n    });\r\n\r\n    // Convert pixel space to clip space.\r\n    const matrix = mat4.orthographic(0, width, height, 0, -1, 1);\r\n    const matrixLocation = gl.getUniformLocation(triProgram, 'u_matrix');\r\n    gl.uniformMatrix4fv(matrixLocation, false, matrix);\r\n\r\n    const positionLocation = gl.getAttribLocation(triProgram, 'a_position');\r\n    const positionBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\r\n    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);\r\n    gl.enableVertexAttribArray(positionLocation);\r\n\r\n    const texcoordLocation = gl.getAttribLocation(triProgram, 'a_texcoord');\r\n    const texcoordBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texcoords), gl.STATIC_DRAW);\r\n    gl.vertexAttribPointer(texcoordLocation, 2, gl.FLOAT, false, 0, 0);\r\n    gl.enableVertexAttribArray(texcoordLocation);\r\n\r\n    gl.drawArrays(gl.TRIANGLES, 0, vertices.length / 2);\r\n  }\r\n\r\n  if (renderEdges) {\r\n    const edgeProgram = createProgram(\r\n      gl,\r\n      EDGE_FRAGMENT_SHADER,\r\n      EDGE_VERTEX_SHADER,\r\n    );\r\n    gl.useProgram(edgeProgram);\r\n    const matrix = mat4.orthographic(0, width, height, 0, -1, 1);\r\n    const matrixLocation = gl.getUniformLocation(edgeProgram, 'u_matrix');\r\n    gl.uniformMatrix4fv(matrixLocation, false, matrix);\r\n\r\n    const burnval = Array.isArray(renderEdges) ? renderEdges : [0, 0, 0, 255];\r\n    const burnvalLocation = gl.getUniformLocation(edgeProgram, 'u_val');\r\n    const isFloat = true;\r\n    if (isFloat) {\r\n      gl.uniform4fv(burnvalLocation, burnval);\r\n    } else {\r\n      gl.uniform4iv(burnvalLocation, burnval);\r\n    }\r\n\r\n    const positionLocation = gl.getAttribLocation(edgeProgram, 'a_position');\r\n    const positionBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);\r\n    gl.enableVertexAttribArray(positionLocation);\r\n\r\n    /** @type {Array<number>} */\r\n    const lines = triangulation.getTriangles().reduce(function (\r\n      /** @type {Array<number>} */ lines,\r\n      triangle,\r\n    ) {\r\n      const target = triangle.target;\r\n      const {u1, v1, u0, v0, u2, v2} = getUVs(target);\r\n\r\n      return lines.concat([u1, v1, u0, v0, u0, v0, u2, v2, u2, v2, u1, v1]);\r\n    }, []);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(lines), gl.STATIC_DRAW);\r\n    gl.drawArrays(gl.LINES, 0, lines.length / 2);\r\n  }\r\n\r\n  return {\r\n    width,\r\n    height,\r\n    framebuffer: resultFrameBuffer,\r\n    texture: resultTexture,\r\n  };\r\n}\r\n", "/**\r\n * @module ol/reproj/DataTile\r\n */\r\nimport {ERROR_THRESHOLD} from './common.js';\r\n\r\nimport DataTile, {asArrayLike, asImageLike, toArray} from '../DataTile.js';\r\nimport EventType from '../events/EventType.js';\r\nimport TileState from '../TileState.js';\r\nimport Triangulation from './Triangulation.js';\r\nimport {calculateSourceExtentResolution} from '../reproj.js';\r\nimport {\r\n  canvasGLPool,\r\n  createCanvasContextWebGL,\r\n  releaseGLCanvas,\r\n  render as renderReprojected,\r\n} from './glreproj.js';\r\nimport {clamp} from '../math.js';\r\nimport {createCanvasContext2D} from '../dom.js';\r\nimport {getArea, getIntersection, getWidth, wrapAndSliceX} from '../extent.js';\r\nimport {listen, unlistenByKey} from '../events.js';\r\n\r\n/**\r\n * @typedef {function(number, number, number, number) : import(\"../DataTile.js\").default} TileGetter\r\n */\r\n\r\n/**\r\n * @typedef {Object} TileOffset\r\n * @property {DataTile} tile Tile.\r\n * @property {number} offset Offset.\r\n */\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {import(\"../proj/Projection.js\").default} sourceProj Source projection.\r\n * @property {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\r\n * @property {import(\"../proj/Projection.js\").default} targetProj Target projection.\r\n * @property {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\r\n * @property {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\r\n * @property {import(\"../tilecoord.js\").TileCoord} [wrappedTileCoord] Coordinate of the tile wrapped in X.\r\n * @property {number} pixelRatio Pixel ratio.\r\n * @property {number} gutter Gutter of the source tiles.\r\n * @property {TileGetter} getTileFunction Function returning source tiles (z, x, y, pixelRatio).\r\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\r\n * the nearest neighbor is used when resampling.\r\n * @property {number} [errorThreshold] Acceptable reprojection error (in px).\r\n * @property {number} [transition=250] A duration for tile opacity\r\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\r\n * @property {import(\"../transform.js\").Transform} [transformMatrix] Source transform matrix.\r\n * @property {boolean} [renderEdges] Render reprojection edges.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Class encapsulating single reprojected data tile.\r\n * See {@link module:ol/source/DataTile~DataTileSource}.\r\n *\r\n */\r\nclass ReprojDataTile extends DataTile {\r\n  /**\r\n   * @param {Options} options Tile options.\r\n   */\r\n  constructor(options) {\r\n    super({\r\n      tileCoord: options.tileCoord,\r\n      loader: () => Promise.resolve(new Uint8ClampedArray(4)),\r\n      interpolate: options.interpolate,\r\n      transition: options.transition,\r\n    });\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean | Array<number>}\r\n     */\r\n    this.renderEdges_ =\r\n      options.renderEdges !== undefined ? options.renderEdges : false;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.pixelRatio_ = options.pixelRatio;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.gutter_ = options.gutter;\r\n\r\n    /**\r\n     * @type {import(\"../DataTile.js\").Data}\r\n     * @private\r\n     */\r\n    this.reprojData_ = null;\r\n\r\n    /**\r\n     * @type {Error}\r\n     * @private\r\n     */\r\n    this.reprojError_ = null;\r\n\r\n    /**\r\n     * @type {import('../size.js').Size}\r\n     * @private\r\n     */\r\n    this.reprojSize_ = undefined;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\r\n     */\r\n    this.sourceTileGrid_ = options.sourceTileGrid;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\r\n     */\r\n    this.targetTileGrid_ = options.targetTileGrid;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../tilecoord.js\").TileCoord}\r\n     */\r\n    this.wrappedTileCoord_ = options.wrappedTileCoord || options.tileCoord;\r\n\r\n    /**\r\n     * @private\r\n     * @type {!Array<TileOffset>}\r\n     */\r\n    this.sourceTiles_ = [];\r\n\r\n    /**\r\n     * @private\r\n     * @type {?Array<import(\"../events.js\").EventsKey>}\r\n     */\r\n    this.sourcesListenerKeys_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.sourceZ_ = 0;\r\n\r\n    const sourceProj = options.sourceProj;\r\n    const sourceProjExtent = sourceProj.getExtent();\r\n    const sourceTileGridExtent = options.sourceTileGrid.getExtent();\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../extent.js\").Extent}\r\n     */\r\n    this.clipExtent_ = sourceProj.canWrapX()\r\n      ? sourceTileGridExtent\r\n        ? getIntersection(sourceProjExtent, sourceTileGridExtent)\r\n        : sourceProjExtent\r\n      : sourceTileGridExtent;\r\n\r\n    const targetExtent = this.targetTileGrid_.getTileCoordExtent(\r\n      this.wrappedTileCoord_,\r\n    );\r\n    const maxTargetExtent = this.targetTileGrid_.getExtent();\r\n    let maxSourceExtent = this.sourceTileGrid_.getExtent();\r\n\r\n    const limitedTargetExtent = maxTargetExtent\r\n      ? getIntersection(targetExtent, maxTargetExtent)\r\n      : targetExtent;\r\n\r\n    if (getArea(limitedTargetExtent) === 0) {\r\n      // Tile is completely outside range -> EMPTY\r\n      // TODO: is it actually correct that the source even creates the tile ?\r\n      this.state = TileState.EMPTY;\r\n      return;\r\n    }\r\n\r\n    if (sourceProjExtent) {\r\n      if (!maxSourceExtent) {\r\n        maxSourceExtent = sourceProjExtent;\r\n      } else {\r\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\r\n      }\r\n    }\r\n\r\n    const targetResolution = this.targetTileGrid_.getResolution(\r\n      this.wrappedTileCoord_[0],\r\n    );\r\n\r\n    const targetProj = options.targetProj;\r\n    const sourceResolution = calculateSourceExtentResolution(\r\n      sourceProj,\r\n      targetProj,\r\n      limitedTargetExtent,\r\n      targetResolution,\r\n    );\r\n\r\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\r\n      // invalid sourceResolution -> EMPTY\r\n      // probably edges of the projections when no extent is defined\r\n      this.state = TileState.EMPTY;\r\n      return;\r\n    }\r\n\r\n    const errorThresholdInPixels =\r\n      options.errorThreshold !== undefined\r\n        ? options.errorThreshold\r\n        : ERROR_THRESHOLD;\r\n\r\n    /**\r\n     * @private\r\n     * @type {!import(\"./Triangulation.js\").default}\r\n     */\r\n    this.triangulation_ = new Triangulation(\r\n      sourceProj,\r\n      targetProj,\r\n      limitedTargetExtent,\r\n      maxSourceExtent,\r\n      sourceResolution * errorThresholdInPixels,\r\n      targetResolution,\r\n      options.transformMatrix,\r\n    );\r\n\r\n    if (this.triangulation_.getTriangles().length === 0) {\r\n      // no valid triangles -> EMPTY\r\n      this.state = TileState.EMPTY;\r\n      return;\r\n    }\r\n\r\n    this.sourceZ_ = this.sourceTileGrid_.getZForResolution(sourceResolution);\r\n    let sourceExtent = this.triangulation_.calculateSourceExtent();\r\n\r\n    if (maxSourceExtent) {\r\n      if (sourceProj.canWrapX()) {\r\n        sourceExtent[1] = clamp(\r\n          sourceExtent[1],\r\n          maxSourceExtent[1],\r\n          maxSourceExtent[3],\r\n        );\r\n        sourceExtent[3] = clamp(\r\n          sourceExtent[3],\r\n          maxSourceExtent[1],\r\n          maxSourceExtent[3],\r\n        );\r\n      } else {\r\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\r\n      }\r\n    }\r\n\r\n    if (!getArea(sourceExtent)) {\r\n      this.state = TileState.EMPTY;\r\n    } else {\r\n      let worldWidth = 0;\r\n      let worldsAway = 0;\r\n      if (sourceProj.canWrapX()) {\r\n        worldWidth = getWidth(sourceProjExtent);\r\n        worldsAway = Math.floor(\r\n          (sourceExtent[0] - sourceProjExtent[0]) / worldWidth,\r\n        );\r\n      }\r\n\r\n      const sourceExtents = wrapAndSliceX(\r\n        sourceExtent.slice(),\r\n        sourceProj,\r\n        true,\r\n      );\r\n      sourceExtents.forEach((extent) => {\r\n        const sourceRange = this.sourceTileGrid_.getTileRangeForExtentAndZ(\r\n          extent,\r\n          this.sourceZ_,\r\n        );\r\n        const getTile = options.getTileFunction;\r\n        for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\r\n          for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\r\n            const tile = getTile(this.sourceZ_, srcX, srcY, this.pixelRatio_);\r\n            if (tile) {\r\n              const offset = worldsAway * worldWidth;\r\n              this.sourceTiles_.push({tile, offset});\r\n            }\r\n          }\r\n        }\r\n        ++worldsAway;\r\n      });\r\n\r\n      if (this.sourceTiles_.length === 0) {\r\n        this.state = TileState.EMPTY;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the tile size.\r\n   * @return {import('../size.js').Size} Tile size.\r\n   * @override\r\n   */\r\n  getSize() {\r\n    return this.reprojSize_;\r\n  }\r\n\r\n  /**\r\n   * Get the data for the tile.\r\n   * @return {import(\"../DataTile.js\").Data} Tile data.\r\n   * @override\r\n   */\r\n  getData() {\r\n    return this.reprojData_;\r\n  }\r\n\r\n  /**\r\n   * Get any loading error.\r\n   * @return {Error} Loading error.\r\n   * @override\r\n   */\r\n  getError() {\r\n    return this.reprojError_;\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  reproject_() {\r\n    const dataSources = [];\r\n    let imageLike = false;\r\n    this.sourceTiles_.forEach((source) => {\r\n      const tile = source.tile;\r\n      if (!tile || tile.getState() !== TileState.LOADED) {\r\n        return;\r\n      }\r\n      const size = tile.getSize();\r\n      const gutter = this.gutter_;\r\n      /**\r\n       * @type {import(\"../DataTile.js\").ArrayLike}\r\n       */\r\n      let tileData;\r\n      const arrayData = asArrayLike(tile.getData());\r\n      if (arrayData) {\r\n        tileData = arrayData;\r\n      } else {\r\n        imageLike = true;\r\n        tileData = toArray(asImageLike(tile.getData()));\r\n      }\r\n      const pixelSize = [size[0] + 2 * gutter, size[1] + 2 * gutter];\r\n      const isFloat = tileData instanceof Float32Array;\r\n      const pixelCount = pixelSize[0] * pixelSize[1];\r\n      const DataType = isFloat ? Float32Array : Uint8ClampedArray;\r\n      const tileDataR = new DataType(tileData.buffer);\r\n      const bytesPerElement = DataType.BYTES_PER_ELEMENT;\r\n      const bytesPerPixel = (bytesPerElement * tileDataR.length) / pixelCount;\r\n      const bytesPerRow = tileDataR.byteLength / pixelSize[1];\r\n      const bandCount = Math.floor(\r\n        bytesPerRow / bytesPerElement / pixelSize[0],\r\n      );\r\n      const extent = this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord);\r\n      extent[0] += source.offset;\r\n      extent[2] += source.offset;\r\n      const clipExtent = this.clipExtent_?.slice();\r\n      if (clipExtent) {\r\n        clipExtent[0] += source.offset;\r\n        clipExtent[2] += source.offset;\r\n      }\r\n      dataSources.push({\r\n        extent: extent,\r\n        clipExtent: clipExtent,\r\n        data: tileDataR,\r\n        dataType: DataType,\r\n        bytesPerPixel: bytesPerPixel,\r\n        pixelSize: pixelSize,\r\n        bandCount: bandCount,\r\n      });\r\n    });\r\n    this.sourceTiles_.length = 0;\r\n\r\n    if (dataSources.length === 0) {\r\n      this.state = TileState.ERROR;\r\n      this.changed();\r\n      return;\r\n    }\r\n\r\n    const z = this.wrappedTileCoord_[0];\r\n    const size = this.targetTileGrid_.getTileSize(z);\r\n    const targetWidth = typeof size === 'number' ? size : size[0];\r\n    const targetHeight = typeof size === 'number' ? size : size[1];\r\n    const outWidth = targetWidth * this.pixelRatio_;\r\n    const outHeight = targetHeight * this.pixelRatio_;\r\n    const targetResolution = this.targetTileGrid_.getResolution(z);\r\n    const sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);\r\n\r\n    const targetExtent = this.targetTileGrid_.getTileCoordExtent(\r\n      this.wrappedTileCoord_,\r\n    );\r\n\r\n    const bandCount = dataSources[0].bandCount;\r\n    const dataR = new dataSources[0].dataType(bandCount * outWidth * outHeight);\r\n\r\n    const gl = createCanvasContextWebGL(outWidth, outHeight, canvasGLPool, {\r\n      premultipliedAlpha: false,\r\n      antialias: false,\r\n    });\r\n\r\n    let willInterpolate;\r\n    const format = gl.RGBA;\r\n    let textureType;\r\n    if (dataSources[0].dataType == Float32Array) {\r\n      textureType = gl.FLOAT;\r\n      gl.getExtension('WEBGL_color_buffer_float');\r\n      gl.getExtension('OES_texture_float');\r\n      gl.getExtension('EXT_float_blend');\r\n      const extension = gl.getExtension('OES_texture_float_linear');\r\n      const canInterpolate = extension !== null;\r\n      willInterpolate = canInterpolate && this.interpolate;\r\n    } else {\r\n      textureType = gl.UNSIGNED_BYTE;\r\n      willInterpolate = this.interpolate;\r\n    }\r\n\r\n    const BANDS_PR_REPROJ = 4;\r\n    const reprojs = Math.ceil(bandCount / BANDS_PR_REPROJ);\r\n    for (let reproj = reprojs - 1; reproj >= 0; --reproj) {\r\n      const sources = [];\r\n      for (let i = 0, len = dataSources.length; i < len; ++i) {\r\n        const dataSource = dataSources[i];\r\n\r\n        const pixelSize = dataSource.pixelSize;\r\n        const width = pixelSize[0];\r\n        const height = pixelSize[1];\r\n\r\n        const data = new dataSource.dataType(BANDS_PR_REPROJ * width * height);\r\n        const dataS = dataSource.data;\r\n        let offset = reproj * BANDS_PR_REPROJ;\r\n        for (let j = 0, len = data.length; j < len; j += BANDS_PR_REPROJ) {\r\n          data[j] = dataS[offset];\r\n          data[j + 1] = dataS[offset + 1];\r\n          data[j + 2] = dataS[offset + 2];\r\n          data[j + 3] = dataS[offset + 3];\r\n          offset += bandCount;\r\n        }\r\n\r\n        const texture = gl.createTexture();\r\n        gl.bindTexture(gl.TEXTURE_2D, texture);\r\n\r\n        if (willInterpolate) {\r\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n        } else {\r\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\r\n        }\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n        gl.texImage2D(\r\n          gl.TEXTURE_2D,\r\n          0,\r\n          format,\r\n          width,\r\n          height,\r\n          0,\r\n          format,\r\n          textureType,\r\n          data,\r\n        );\r\n\r\n        sources.push({\r\n          extent: dataSource.extent,\r\n          clipExtent: dataSource.clipExtent,\r\n          texture: texture,\r\n          width: width,\r\n          height: height,\r\n        });\r\n      }\r\n\r\n      const {framebuffer, width, height} = renderReprojected(\r\n        gl,\r\n        targetWidth,\r\n        targetHeight,\r\n        this.pixelRatio_,\r\n        sourceResolution,\r\n        targetResolution,\r\n        targetExtent,\r\n        this.triangulation_,\r\n        sources,\r\n        this.gutter_,\r\n        textureType,\r\n        this.renderEdges_,\r\n        willInterpolate,\r\n      );\r\n\r\n      // The texture is always RGBA.\r\n      const rows = width;\r\n      const cols = height * BANDS_PR_REPROJ;\r\n      const data = new dataSources[0].dataType(rows * cols);\r\n      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\r\n      gl.readPixels(0, 0, width, height, gl.RGBA, textureType, data);\r\n\r\n      let offset = reproj * BANDS_PR_REPROJ;\r\n      for (let i = 0, len = data.length; i < len; i += BANDS_PR_REPROJ) {\r\n        // The data read by `readPixels` is flipped in the y-axis so flip it again.\r\n        const flipY = (rows - 1 - ((i / cols) | 0)) * cols + (i % cols);\r\n        dataR[offset] = data[flipY];\r\n        dataR[offset + 1] = data[flipY + 1];\r\n        dataR[offset + 2] = data[flipY + 2];\r\n        dataR[offset + 3] = data[flipY + 3];\r\n        offset += bandCount;\r\n      }\r\n    }\r\n\r\n    releaseGLCanvas(gl);\r\n    canvasGLPool.push(gl.canvas);\r\n\r\n    if (imageLike) {\r\n      const context = createCanvasContext2D(targetWidth, targetHeight);\r\n      const imageData = new ImageData(dataR, targetWidth);\r\n      context.putImageData(imageData, 0, 0);\r\n      this.reprojData_ = context.canvas;\r\n    } else {\r\n      this.reprojData_ = dataR;\r\n    }\r\n    this.reprojSize_ = [Math.round(outWidth), Math.round(outHeight)];\r\n    this.state = TileState.LOADED;\r\n    this.changed();\r\n  }\r\n\r\n  /**\r\n   * Load not yet loaded URI.\r\n   * @override\r\n   */\r\n  load() {\r\n    if (this.state !== TileState.IDLE && this.state !== TileState.ERROR) {\r\n      return;\r\n    }\r\n    this.state = TileState.LOADING;\r\n    this.changed();\r\n\r\n    let leftToLoad = 0;\r\n\r\n    this.sourcesListenerKeys_ = [];\r\n    this.sourceTiles_.forEach(({tile}) => {\r\n      const state = tile.getState();\r\n      if (state !== TileState.IDLE && state !== TileState.LOADING) {\r\n        return;\r\n      }\r\n      leftToLoad++;\r\n\r\n      const sourceListenKey = listen(tile, EventType.CHANGE, () => {\r\n        const state = tile.getState();\r\n        if (\r\n          state == TileState.LOADED ||\r\n          state == TileState.ERROR ||\r\n          state == TileState.EMPTY\r\n        ) {\r\n          unlistenByKey(sourceListenKey);\r\n          leftToLoad--;\r\n          if (leftToLoad === 0) {\r\n            this.unlistenSources_();\r\n            this.reproject_();\r\n          }\r\n        }\r\n      });\r\n      this.sourcesListenerKeys_.push(sourceListenKey);\r\n    });\r\n\r\n    if (leftToLoad === 0) {\r\n      setTimeout(this.reproject_.bind(this), 0);\r\n    } else {\r\n      this.sourceTiles_.forEach(function ({tile}) {\r\n        const state = tile.getState();\r\n        if (state == TileState.IDLE) {\r\n          tile.load();\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  unlistenSources_() {\r\n    this.sourcesListenerKeys_.forEach(unlistenByKey);\r\n    this.sourcesListenerKeys_ = null;\r\n  }\r\n}\r\n\r\nexport default ReprojDataTile;\r\n", "/**\r\n * @module ol/renderer/canvas/TileLayer\r\n */\r\nimport CanvasLayerRenderer from './Layer.js';\r\nimport DataTile, {asImageLike} from '../../DataTile.js';\r\nimport ImageTile from '../../ImageTile.js';\r\nimport LRUCache from '../../structs/LRUCache.js';\r\nimport ReprojDataTile from '../../reproj/DataTile.js';\r\nimport ReprojTile from '../../reproj/Tile.js';\r\nimport TileRange from '../../TileRange.js';\r\nimport TileState from '../../TileState.js';\r\nimport {\r\n  apply as applyTransform,\r\n  compose as composeTransform,\r\n} from '../../transform.js';\r\nimport {ascending} from '../../array.js';\r\nimport {\r\n  containsCoordinate,\r\n  createEmpty,\r\n  equals,\r\n  getIntersection,\r\n  getTopLeft,\r\n  intersects,\r\n} from '../../extent.js';\r\nimport {createOrUpdate as createTileCoord, getKeyZXY} from '../../tilecoord.js';\r\nimport {fromUserExtent} from '../../proj.js';\r\nimport {getUid} from '../../util.js';\r\nimport {toSize} from '../../size.js';\r\n\r\n/**\r\n * @param {string} sourceKey The source key.\r\n * @param {number} z The tile z level.\r\n * @param {number} x The tile x level.\r\n * @param {number} y The tile y level.\r\n * @return {string} The cache key.\r\n */\r\nfunction getCacheKey(sourceKey, z, x, y) {\r\n  return `${sourceKey},${getKeyZXY(z, x, y)}`;\r\n}\r\n\r\n/**\r\n * @typedef {Object<number, Set<import(\"../../Tile.js\").default>>} TileLookup\r\n */\r\n\r\n/**\r\n * Add a tile to the lookup.\r\n * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\r\n * @param {import(\"../../Tile.js\").default} tile A tile.\r\n * @param {number} z The zoom level.\r\n * @return {boolean} The tile was added to the lookup.\r\n */\r\nfunction addTileToLookup(tilesByZ, tile, z) {\r\n  if (!(z in tilesByZ)) {\r\n    tilesByZ[z] = new Set([tile]);\r\n    return true;\r\n  }\r\n  const set = tilesByZ[z];\r\n  const existing = set.has(tile);\r\n  if (!existing) {\r\n    set.add(tile);\r\n  }\r\n  return !existing;\r\n}\r\n\r\n/**\r\n * Remove a tile from the lookup.\r\n * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\r\n * @param {import(\"../../Tile.js\").default} tile A tile.\r\n * @param {number} z The zoom level.\r\n * @return {boolean} The tile was removed from the lookup.\r\n */\r\nfunction removeTileFromLookup(tilesByZ, tile, z) {\r\n  const set = tilesByZ[z];\r\n  if (set) {\r\n    return set.delete(tile);\r\n  }\r\n  return false;\r\n}\r\n\r\n/**\r\n * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n * @param {import(\"../../extent.js\").Extent} extent The frame extent.\r\n * @return {import(\"../../extent.js\").Extent} Frame extent intersected with layer extents.\r\n */\r\nfunction getRenderExtent(frameState, extent) {\r\n  const layerState = frameState.layerStatesArray[frameState.layerIndex];\r\n  if (layerState.extent) {\r\n    extent = getIntersection(\r\n      extent,\r\n      fromUserExtent(layerState.extent, frameState.viewState.projection),\r\n    );\r\n  }\r\n  const source = /** @type {import(\"../../source/Tile.js\").default} */ (\r\n    layerState.layer.getRenderSource()\r\n  );\r\n  if (!source.getWrapX()) {\r\n    const gridExtent = source\r\n      .getTileGridForProjection(frameState.viewState.projection)\r\n      .getExtent();\r\n    if (gridExtent) {\r\n      extent = getIntersection(extent, gridExtent);\r\n    }\r\n  }\r\n  return extent;\r\n}\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {number} [cacheSize=512] The cache size.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Canvas renderer for tile layers.\r\n * @api\r\n * @template {import(\"../../layer/Tile.js\").default|import(\"../../layer/VectorTile.js\").default} [LayerType=import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default]\r\n * @extends {CanvasLayerRenderer<LayerType>}\r\n */\r\nclass CanvasTileLayerRenderer extends CanvasLayerRenderer {\r\n  /**\r\n   * @param {LayerType} tileLayer Tile layer.\r\n   * @param {Options} [options] Options.\r\n   */\r\n  constructor(tileLayer, options) {\r\n    super(tileLayer);\r\n\r\n    options = options || {};\r\n\r\n    /**\r\n     * Rendered extent has changed since the previous `renderFrame()` call\r\n     * @type {boolean}\r\n     */\r\n    this.extentChanged = true;\r\n\r\n    /**\r\n     * The last call to `renderFrame` was completed with all tiles loaded\r\n     * @type {boolean}\r\n     */\r\n    this.renderComplete = false;\r\n\r\n    /**\r\n     * @private\r\n     * @type {?import(\"../../extent.js\").Extent}\r\n     */\r\n    this.renderedExtent_ = null;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {number}\r\n     */\r\n    this.renderedPixelRatio;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {import(\"../../proj/Projection.js\").default|null}\r\n     */\r\n    this.renderedProjection = null;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {number}\r\n     */\r\n    this.renderedRevision;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {!Array<import(\"../../Tile.js\").default>}\r\n     */\r\n    this.renderedTiles = [];\r\n\r\n    /**\r\n     * @private\r\n     * @type {string}\r\n     */\r\n    this.renderedSourceKey_;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.renderedSourceRevision_;\r\n\r\n    /**\r\n     * @protected\r\n     * @type {import(\"../../extent.js\").Extent}\r\n     */\r\n    this.tempExtent = createEmpty();\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../../TileRange.js\").default}\r\n     */\r\n    this.tempTileRange_ = new TileRange(0, 0, 0, 0);\r\n\r\n    /**\r\n     * @type {import(\"../../tilecoord.js\").TileCoord}\r\n     * @private\r\n     */\r\n    this.tempTileCoord_ = createTileCoord(0, 0, 0);\r\n\r\n    const cacheSize = options.cacheSize !== undefined ? options.cacheSize : 512;\r\n\r\n    /**\r\n     * @type {import(\"../../structs/LRUCache.js\").default<import(\"../../Tile.js\").default>}\r\n     * @private\r\n     */\r\n    this.tileCache_ = new LRUCache(cacheSize);\r\n\r\n    this.maxStaleKeys = cacheSize * 0.5;\r\n  }\r\n\r\n  /**\r\n   * @return {LRUCache} Tile cache.\r\n   */\r\n  getTileCache() {\r\n    return this.tileCache_;\r\n  }\r\n\r\n  /**\r\n   * Get a tile from the cache or create one if needed.\r\n   *\r\n   * @param {number} z Tile coordinate z.\r\n   * @param {number} x Tile coordinate x.\r\n   * @param {number} y Tile coordinate y.\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n   * @return {import(\"../../Tile.js\").default|null} Tile (or null if outside source extent).\r\n   * @protected\r\n   */\r\n  getOrCreateTile(z, x, y, frameState) {\r\n    const tileCache = this.tileCache_;\r\n    const tileLayer = this.getLayer();\r\n    const tileSource = tileLayer.getSource();\r\n    const cacheKey = getCacheKey(tileSource.getKey(), z, x, y);\r\n\r\n    /** @type {import(\"../../Tile.js\").default} */\r\n    let tile;\r\n\r\n    if (tileCache.containsKey(cacheKey)) {\r\n      tile = tileCache.get(cacheKey);\r\n    } else {\r\n      tile = tileSource.getTile(\r\n        z,\r\n        x,\r\n        y,\r\n        frameState.pixelRatio,\r\n        frameState.viewState.projection,\r\n      );\r\n      if (!tile) {\r\n        return null;\r\n      }\r\n      tileCache.set(cacheKey, tile);\r\n    }\r\n    return tile;\r\n  }\r\n\r\n  /**\r\n   * @param {number} z Tile coordinate z.\r\n   * @param {number} x Tile coordinate x.\r\n   * @param {number} y Tile coordinate y.\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n   * @return {import(\"../../Tile.js\").default|null} Tile (or null if outside source extent).\r\n   * @protected\r\n   */\r\n  getTile(z, x, y, frameState) {\r\n    const tile = this.getOrCreateTile(z, x, y, frameState);\r\n    if (!tile) {\r\n      return null;\r\n    }\r\n    return tile;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\r\n   * @return {Uint8ClampedArray} Data at the pixel location.\r\n   * @override\r\n   */\r\n  getData(pixel) {\r\n    const frameState = this.frameState;\r\n    if (!frameState) {\r\n      return null;\r\n    }\r\n\r\n    const layer = this.getLayer();\r\n    const coordinate = applyTransform(\r\n      frameState.pixelToCoordinateTransform,\r\n      pixel.slice(),\r\n    );\r\n\r\n    const layerExtent = layer.getExtent();\r\n    if (layerExtent) {\r\n      if (!containsCoordinate(layerExtent, coordinate)) {\r\n        return null;\r\n      }\r\n    }\r\n\r\n    const viewState = frameState.viewState;\r\n    const source = layer.getRenderSource();\r\n    const tileGrid = source.getTileGridForProjection(viewState.projection);\r\n    const tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);\r\n\r\n    for (\r\n      let z = tileGrid.getZForResolution(viewState.resolution);\r\n      z >= tileGrid.getMinZoom();\r\n      --z\r\n    ) {\r\n      const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);\r\n      const tile = this.getTile(z, tileCoord[1], tileCoord[2], frameState);\r\n      if (!tile || tile.getState() !== TileState.LOADED) {\r\n        continue;\r\n      }\r\n\r\n      const tileOrigin = tileGrid.getOrigin(z);\r\n      const tileSize = toSize(tileGrid.getTileSize(z));\r\n      const tileResolution = tileGrid.getResolution(z);\r\n\r\n      /**\r\n       * @type {import('../../DataTile.js').ImageLike}\r\n       */\r\n      let image;\r\n      if (tile instanceof ImageTile || tile instanceof ReprojTile) {\r\n        image = tile.getImage();\r\n      } else if (tile instanceof DataTile) {\r\n        image = asImageLike(tile.getData());\r\n        if (!image) {\r\n          continue;\r\n        }\r\n      } else {\r\n        continue;\r\n      }\r\n\r\n      const col = Math.floor(\r\n        tilePixelRatio *\r\n          ((coordinate[0] - tileOrigin[0]) / tileResolution -\r\n            tileCoord[1] * tileSize[0]),\r\n      );\r\n\r\n      const row = Math.floor(\r\n        tilePixelRatio *\r\n          ((tileOrigin[1] - coordinate[1]) / tileResolution -\r\n            tileCoord[2] * tileSize[1]),\r\n      );\r\n\r\n      const gutter = Math.round(\r\n        tilePixelRatio * source.getGutterForProjection(viewState.projection),\r\n      );\r\n\r\n      return this.getImageData(image, col + gutter, row + gutter);\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Determine whether render should be called.\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n   * @return {boolean} Layer is ready to be rendered.\r\n   * @override\r\n   */\r\n  prepareFrame(frameState) {\r\n    if (!this.renderedProjection) {\r\n      this.renderedProjection = frameState.viewState.projection;\r\n    } else if (frameState.viewState.projection !== this.renderedProjection) {\r\n      this.tileCache_.clear();\r\n      this.renderedProjection = frameState.viewState.projection;\r\n    }\r\n\r\n    const source = this.getLayer().getSource();\r\n    if (!source) {\r\n      return false;\r\n    }\r\n    const sourceRevision = source.getRevision();\r\n    if (!this.renderedRevision_) {\r\n      this.renderedRevision_ = sourceRevision;\r\n    } else if (this.renderedRevision_ !== sourceRevision) {\r\n      this.renderedRevision_ = sourceRevision;\r\n      if (this.renderedSourceKey_ === source.getKey()) {\r\n        this.tileCache_.clear();\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n   * @param {import(\"../../extent.js\").Extent} extent The extent to be rendered.\r\n   * @param {number} initialZ The zoom level.\r\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\r\n   * @param {number} preload Number of additional levels to load.\r\n   */\r\n  enqueueTiles(frameState, extent, initialZ, tilesByZ, preload) {\r\n    const viewState = frameState.viewState;\r\n    const tileLayer = this.getLayer();\r\n    const tileSource = tileLayer.getRenderSource();\r\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\r\n\r\n    const tileSourceKey = getUid(tileSource);\r\n    if (!(tileSourceKey in frameState.wantedTiles)) {\r\n      frameState.wantedTiles[tileSourceKey] = {};\r\n    }\r\n\r\n    const wantedTiles = frameState.wantedTiles[tileSourceKey];\r\n\r\n    const map = tileLayer.getMapInternal();\r\n    const minZ = Math.max(\r\n      initialZ - preload,\r\n      tileGrid.getMinZoom(),\r\n      tileGrid.getZForResolution(\r\n        Math.min(\r\n          tileLayer.getMaxResolution(),\r\n          map\r\n            ? map\r\n                .getView()\r\n                .getResolutionForZoom(Math.max(tileLayer.getMinZoom(), 0))\r\n            : tileGrid.getResolution(0),\r\n        ),\r\n        tileSource.zDirection,\r\n      ),\r\n    );\r\n    for (let z = initialZ; z >= minZ; --z) {\r\n      const tileRange = tileGrid.getTileRangeForExtentAndZ(\r\n        extent,\r\n        z,\r\n        this.tempTileRange_,\r\n      );\r\n\r\n      const tileResolution = tileGrid.getResolution(z);\r\n\r\n      for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\r\n        for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\r\n          const tile = this.getTile(z, x, y, frameState);\r\n          if (!tile) {\r\n            continue;\r\n          }\r\n          const added = addTileToLookup(tilesByZ, tile, z);\r\n          if (!added) {\r\n            continue;\r\n          }\r\n\r\n          const tileQueueKey = tile.getKey();\r\n          wantedTiles[tileQueueKey] = true;\r\n\r\n          if (tile.getState() === TileState.IDLE) {\r\n            if (!frameState.tileQueue.isKeyQueued(tileQueueKey)) {\r\n              const tileCoord = createTileCoord(z, x, y, this.tempTileCoord_);\r\n              frameState.tileQueue.enqueue([\r\n                tile,\r\n                tileSourceKey,\r\n                tileGrid.getTileCoordCenter(tileCoord),\r\n                tileResolution,\r\n              ]);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Look for tiles covering the provided tile coordinate at an alternate\r\n   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.\r\n   * @param {import(\"../../tilecoord.js\").TileCoord} tileCoord The target tile coordinate.\r\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\r\n   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.\r\n   * @private\r\n   */\r\n  findStaleTile_(tileCoord, tilesByZ) {\r\n    const tileCache = this.tileCache_;\r\n    const z = tileCoord[0];\r\n    const x = tileCoord[1];\r\n    const y = tileCoord[2];\r\n    const staleKeys = this.getStaleKeys();\r\n    for (let i = 0; i < staleKeys.length; ++i) {\r\n      const cacheKey = getCacheKey(staleKeys[i], z, x, y);\r\n      if (tileCache.containsKey(cacheKey)) {\r\n        const tile = tileCache.get(cacheKey);\r\n        if (tile.getState() === TileState.LOADED) {\r\n          tile.endTransition(getUid(this));\r\n          addTileToLookup(tilesByZ, tile, z);\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Look for tiles covering the provided tile coordinate at an alternate\r\n   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.\r\n   * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid The tile grid.\r\n   * @param {import(\"../../tilecoord.js\").TileCoord} tileCoord The target tile coordinate.\r\n   * @param {number} altZ The alternate zoom level.\r\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\r\n   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.\r\n   * @private\r\n   */\r\n  findAltTiles_(tileGrid, tileCoord, altZ, tilesByZ) {\r\n    const tileRange = tileGrid.getTileRangeForTileCoordAndZ(\r\n      tileCoord,\r\n      altZ,\r\n      this.tempTileRange_,\r\n    );\r\n\r\n    if (!tileRange) {\r\n      return false;\r\n    }\r\n\r\n    let covered = true;\r\n    const tileCache = this.tileCache_;\r\n    const source = this.getLayer().getRenderSource();\r\n    const sourceKey = source.getKey();\r\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\r\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\r\n        const cacheKey = getCacheKey(sourceKey, altZ, x, y);\r\n        let loaded = false;\r\n        if (tileCache.containsKey(cacheKey)) {\r\n          const tile = tileCache.get(cacheKey);\r\n          if (tile.getState() === TileState.LOADED) {\r\n            addTileToLookup(tilesByZ, tile, altZ);\r\n            loaded = true;\r\n          }\r\n        }\r\n        if (!loaded) {\r\n          covered = false;\r\n        }\r\n      }\r\n    }\r\n    return covered;\r\n  }\r\n\r\n  /**\r\n   * Render the layer.\r\n   *\r\n   * The frame rendering logic has three parts:\r\n   *\r\n   *  1. Enqueue tiles\r\n   *  2. Find alt tiles for those that are not yet loaded\r\n   *  3. Render loaded tiles\r\n   *\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n   * @param {HTMLElement} target Target that may be used to render content to.\r\n   * @return {HTMLElement} The rendered element.\r\n   * @override\r\n   */\r\n  renderFrame(frameState, target) {\r\n    let allTilesIdle = true;\r\n    this.renderComplete = true;\r\n\r\n    /**\r\n     * TODO:\r\n     *  * maybe skip transition when not fully opaque\r\n     *  * decide if this.renderComplete is useful\r\n     */\r\n\r\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\r\n    const viewState = frameState.viewState;\r\n    const projection = viewState.projection;\r\n    const viewResolution = viewState.resolution;\r\n    const viewCenter = viewState.center;\r\n    const pixelRatio = frameState.pixelRatio;\r\n\r\n    const tileLayer = this.getLayer();\r\n    const tileSource = tileLayer.getSource();\r\n    const sourceRevision = tileSource.getRevision();\r\n    const tileGrid = tileSource.getTileGridForProjection(projection);\r\n    const z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);\r\n    const tileResolution = tileGrid.getResolution(z);\r\n\r\n    const sourceKey = tileSource.getKey();\r\n    if (!this.renderedSourceKey_) {\r\n      this.renderedSourceKey_ = sourceKey;\r\n    } else if (this.renderedSourceKey_ !== sourceKey) {\r\n      this.prependStaleKey(this.renderedSourceKey_);\r\n      this.renderedSourceKey_ = sourceKey;\r\n    }\r\n\r\n    let frameExtent = frameState.extent;\r\n    const tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\r\n\r\n    this.prepareContainer(frameState, target);\r\n\r\n    // desired dimensions of the canvas in pixels\r\n    const width = this.context.canvas.width;\r\n    const height = this.context.canvas.height;\r\n\r\n    const layerExtent =\r\n      layerState.extent && fromUserExtent(layerState.extent, projection);\r\n    if (layerExtent) {\r\n      frameExtent = getIntersection(\r\n        frameExtent,\r\n        fromUserExtent(layerState.extent, projection),\r\n      );\r\n    }\r\n\r\n    const dx = (tileResolution * width) / 2 / tilePixelRatio;\r\n    const dy = (tileResolution * height) / 2 / tilePixelRatio;\r\n    const canvasExtent = [\r\n      viewCenter[0] - dx,\r\n      viewCenter[1] - dy,\r\n      viewCenter[0] + dx,\r\n      viewCenter[1] + dy,\r\n    ];\r\n\r\n    /**\r\n     * @type {TileLookup}\r\n     */\r\n    const tilesByZ = {};\r\n\r\n    this.renderedTiles.length = 0;\r\n\r\n    /**\r\n     * Part 1: Enqueue tiles\r\n     */\r\n\r\n    const preload = tileLayer.getPreload();\r\n    if (frameState.nextExtent) {\r\n      const targetZ = tileGrid.getZForResolution(\r\n        viewState.nextResolution,\r\n        tileSource.zDirection,\r\n      );\r\n      const nextExtent = getRenderExtent(frameState, frameState.nextExtent);\r\n      this.enqueueTiles(frameState, nextExtent, targetZ, tilesByZ, preload);\r\n    }\r\n\r\n    const renderExtent = getRenderExtent(frameState, frameExtent);\r\n    this.enqueueTiles(frameState, renderExtent, z, tilesByZ, 0);\r\n    if (preload > 0) {\r\n      setTimeout(() => {\r\n        this.enqueueTiles(\r\n          frameState,\r\n          renderExtent,\r\n          z - 1,\r\n          tilesByZ,\r\n          preload - 1,\r\n        );\r\n      }, 0);\r\n    }\r\n\r\n    if (!(z in tilesByZ)) {\r\n      return this.container;\r\n    }\r\n\r\n    /**\r\n     * Part 2: Find alt tiles for those that are not yet loaded\r\n     */\r\n\r\n    const uid = getUid(this);\r\n    const time = frameState.time;\r\n\r\n    // look for cached tiles to use if a target tile is not ready\r\n    for (const tile of tilesByZ[z]) {\r\n      const tileState = tile.getState();\r\n      if (\r\n        (tile instanceof ReprojTile || tile instanceof ReprojDataTile) &&\r\n        tileState === TileState.EMPTY\r\n      ) {\r\n        continue;\r\n      }\r\n      const tileCoord = tile.tileCoord;\r\n\r\n      if (tileState === TileState.LOADED) {\r\n        const alpha = tile.getAlpha(uid, time);\r\n        if (alpha === 1) {\r\n          // no need to look for alt tiles\r\n          tile.endTransition(uid);\r\n          continue;\r\n        }\r\n      }\r\n      if (tileState !== TileState.IDLE) {\r\n        allTilesIdle = false;\r\n      }\r\n      if (tileState !== TileState.ERROR) {\r\n        this.renderComplete = false;\r\n      }\r\n\r\n      const hasStaleTile = this.findStaleTile_(tileCoord, tilesByZ);\r\n      if (hasStaleTile) {\r\n        // use the stale tile before the new tile's transition has completed\r\n        removeTileFromLookup(tilesByZ, tile, z);\r\n        frameState.animate = true;\r\n        continue;\r\n      }\r\n\r\n      // first look for child tiles (at z + 1)\r\n      const coveredByChildren = this.findAltTiles_(\r\n        tileGrid,\r\n        tileCoord,\r\n        z + 1,\r\n        tilesByZ,\r\n      );\r\n\r\n      if (coveredByChildren) {\r\n        continue;\r\n      }\r\n\r\n      // next look for parent tiles\r\n      const minZoom = tileGrid.getMinZoom();\r\n      for (let parentZ = z - 1; parentZ >= minZoom; --parentZ) {\r\n        const coveredByParent = this.findAltTiles_(\r\n          tileGrid,\r\n          tileCoord,\r\n          parentZ,\r\n          tilesByZ,\r\n        );\r\n\r\n        if (coveredByParent) {\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Part 3: Render loaded tiles\r\n     */\r\n\r\n    const canvasScale =\r\n      ((tileResolution / viewResolution) * pixelRatio) / tilePixelRatio;\r\n\r\n    const context = this.getRenderContext(frameState);\r\n\r\n    // set scale transform for calculating tile positions on the canvas\r\n    composeTransform(\r\n      this.tempTransform,\r\n      width / 2,\r\n      height / 2,\r\n      canvasScale,\r\n      canvasScale,\r\n      0,\r\n      -width / 2,\r\n      -height / 2,\r\n    );\r\n\r\n    if (layerState.extent) {\r\n      this.clipUnrotated(context, frameState, layerExtent);\r\n    }\r\n\r\n    if (!tileSource.getInterpolate()) {\r\n      context.imageSmoothingEnabled = false;\r\n    }\r\n\r\n    this.preRender(context, frameState);\r\n\r\n    /** @type {Array<number>} */\r\n    const zs = Object.keys(tilesByZ).map(Number);\r\n    zs.sort(ascending);\r\n\r\n    let currentClip;\r\n    const clips = [];\r\n    const clipZs = [];\r\n    for (let i = zs.length - 1; i >= 0; --i) {\r\n      const currentZ = zs[i];\r\n      const currentTilePixelSize = tileSource.getTilePixelSize(\r\n        currentZ,\r\n        pixelRatio,\r\n        projection,\r\n      );\r\n      const currentResolution = tileGrid.getResolution(currentZ);\r\n      const currentScale = currentResolution / tileResolution;\r\n      const dx = currentTilePixelSize[0] * currentScale * canvasScale;\r\n      const dy = currentTilePixelSize[1] * currentScale * canvasScale;\r\n      const originTileCoord = tileGrid.getTileCoordForCoordAndZ(\r\n        getTopLeft(canvasExtent),\r\n        currentZ,\r\n      );\r\n      const originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);\r\n      const origin = applyTransform(this.tempTransform, [\r\n        (tilePixelRatio * (originTileExtent[0] - canvasExtent[0])) /\r\n          tileResolution,\r\n        (tilePixelRatio * (canvasExtent[3] - originTileExtent[3])) /\r\n          tileResolution,\r\n      ]);\r\n      const tileGutter =\r\n        tilePixelRatio * tileSource.getGutterForProjection(projection);\r\n      for (const tile of tilesByZ[currentZ]) {\r\n        if (tile.getState() !== TileState.LOADED) {\r\n          continue;\r\n        }\r\n        const tileCoord = tile.tileCoord;\r\n\r\n        // Calculate integer positions and sizes so that tiles align\r\n        const xIndex = originTileCoord[1] - tileCoord[1];\r\n        const nextX = Math.round(origin[0] - (xIndex - 1) * dx);\r\n        const yIndex = originTileCoord[2] - tileCoord[2];\r\n        const nextY = Math.round(origin[1] - (yIndex - 1) * dy);\r\n        const x = Math.round(origin[0] - xIndex * dx);\r\n        const y = Math.round(origin[1] - yIndex * dy);\r\n        const w = nextX - x;\r\n        const h = nextY - y;\r\n        const transition = zs.length === 1;\r\n\r\n        let contextSaved = false;\r\n\r\n        // Clip mask for regions in this tile that already filled by a higher z tile\r\n        currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];\r\n        for (let i = 0, ii = clips.length; i < ii; ++i) {\r\n          if (!transition && currentZ < clipZs[i]) {\r\n            const clip = clips[i];\r\n            if (\r\n              intersects(\r\n                [x, y, x + w, y + h],\r\n                [clip[0], clip[3], clip[4], clip[7]],\r\n              )\r\n            ) {\r\n              if (!contextSaved) {\r\n                context.save();\r\n                contextSaved = true;\r\n              }\r\n              context.beginPath();\r\n              // counter-clockwise (outer ring) for current tile\r\n              context.moveTo(currentClip[0], currentClip[1]);\r\n              context.lineTo(currentClip[2], currentClip[3]);\r\n              context.lineTo(currentClip[4], currentClip[5]);\r\n              context.lineTo(currentClip[6], currentClip[7]);\r\n              // clockwise (inner ring) for higher z tile\r\n              context.moveTo(clip[6], clip[7]);\r\n              context.lineTo(clip[4], clip[5]);\r\n              context.lineTo(clip[2], clip[3]);\r\n              context.lineTo(clip[0], clip[1]);\r\n              context.clip();\r\n            }\r\n          }\r\n        }\r\n        clips.push(currentClip);\r\n        clipZs.push(currentZ);\r\n\r\n        this.drawTile(tile, frameState, x, y, w, h, tileGutter, transition);\r\n        if (contextSaved) {\r\n          context.restore();\r\n        }\r\n        this.renderedTiles.unshift(tile);\r\n\r\n        // TODO: decide if this is necessary\r\n        this.updateUsedTiles(frameState.usedTiles, tileSource, tile);\r\n      }\r\n    }\r\n\r\n    this.renderedRevision = sourceRevision;\r\n    this.renderedResolution = tileResolution;\r\n    this.extentChanged =\r\n      !this.renderedExtent_ || !equals(this.renderedExtent_, canvasExtent);\r\n    this.renderedExtent_ = canvasExtent;\r\n    this.renderedPixelRatio = pixelRatio;\r\n\r\n    this.postRender(this.context, frameState);\r\n\r\n    if (layerState.extent) {\r\n      context.restore();\r\n    }\r\n    context.imageSmoothingEnabled = true;\r\n\r\n    if (this.renderComplete) {\r\n      /**\r\n       * @param {import(\"../../Map.js\").default} map Map.\r\n       * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n       */\r\n      const postRenderFunction = (map, frameState) => {\r\n        const tileSourceKey = getUid(tileSource);\r\n        const wantedTiles = frameState.wantedTiles[tileSourceKey];\r\n        const tilesCount = wantedTiles ? Object.keys(wantedTiles).length : 0;\r\n        this.updateCacheSize(tilesCount);\r\n        this.tileCache_.expireCache();\r\n      };\r\n\r\n      frameState.postRenderFunctions.push(postRenderFunction);\r\n    }\r\n    if (!this.renderComplete && !allTilesIdle) {\r\n      frameState.animate = true;\r\n    }\r\n\r\n    return this.container;\r\n  }\r\n\r\n  /**\r\n   * Increases the cache size if needed\r\n   * @param {number} tileCount Minimum number of tiles needed.\r\n   */\r\n  updateCacheSize(tileCount) {\r\n    this.tileCache_.highWaterMark = Math.max(\r\n      this.tileCache_.highWaterMark,\r\n      tileCount * 2,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../../Tile.js\").default} tile Tile.\r\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\r\n   * @param {number} x Left of the tile.\r\n   * @param {number} y Top of the tile.\r\n   * @param {number} w Width of the tile.\r\n   * @param {number} h Height of the tile.\r\n   * @param {number} gutter Tile gutter.\r\n   * @param {boolean} transition Apply an alpha transition.\r\n   * @protected\r\n   */\r\n  drawTile(tile, frameState, x, y, w, h, gutter, transition) {\r\n    let image;\r\n    if (tile instanceof DataTile) {\r\n      image = asImageLike(tile.getData());\r\n      if (!image) {\r\n        throw new Error('Rendering array data is not yet supported');\r\n      }\r\n    } else {\r\n      image = this.getTileImage(\r\n        /** @type {import(\"../../ImageTile.js\").default} */ (tile),\r\n      );\r\n    }\r\n    if (!image) {\r\n      return;\r\n    }\r\n    const context = this.getRenderContext(frameState);\r\n    const uid = getUid(this);\r\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\r\n    const alpha =\r\n      layerState.opacity *\r\n      (transition ? tile.getAlpha(uid, frameState.time) : 1);\r\n    const alphaChanged = alpha !== context.globalAlpha;\r\n    if (alphaChanged) {\r\n      context.save();\r\n      context.globalAlpha = alpha;\r\n    }\r\n    context.drawImage(\r\n      image,\r\n      gutter,\r\n      gutter,\r\n      image.width - 2 * gutter,\r\n      image.height - 2 * gutter,\r\n      x,\r\n      y,\r\n      w,\r\n      h,\r\n    );\r\n\r\n    if (alphaChanged) {\r\n      context.restore();\r\n    }\r\n    if (alpha !== layerState.opacity) {\r\n      frameState.animate = true;\r\n    } else if (transition) {\r\n      tile.endTransition(uid);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @return {HTMLCanvasElement} Image\r\n   */\r\n  getImage() {\r\n    const context = this.context;\r\n    return context ? context.canvas : null;\r\n  }\r\n\r\n  /**\r\n   * Get the image from a tile.\r\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\r\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\r\n   * @protected\r\n   */\r\n  getTileImage(tile) {\r\n    return tile.getImage();\r\n  }\r\n\r\n  /**\r\n   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.\r\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\r\n   * @param {import('../../Tile.js').default} tile Tile.\r\n   * @protected\r\n   */\r\n  updateUsedTiles(usedTiles, tileSource, tile) {\r\n    // FIXME should we use tilesToDrawByZ instead?\r\n    const tileSourceKey = getUid(tileSource);\r\n    if (!(tileSourceKey in usedTiles)) {\r\n      usedTiles[tileSourceKey] = {};\r\n    }\r\n    usedTiles[tileSourceKey][tile.getKey()] = true;\r\n  }\r\n}\r\n\r\nexport default CanvasTileLayerRenderer;\r\n", "/**\r\n * @module ol/layer/Tile\r\n */\r\nimport BaseTileLayer from './BaseTile.js';\r\nimport CanvasTileLayerRenderer from '../renderer/canvas/TileLayer.js';\r\n\r\n/**\r\n * @classdesc\r\n * For layer sources that provide pre-rendered, tiled images in grids that are\r\n * organized by zoom levels for specific resolutions.\r\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\r\n * property on the layer object; for example, setting `title: 'My Title'` in the\r\n * options means that `title` is observable, and has get/set accessors.\r\n *\r\n * @template {import(\"../source/Tile.js\").default} [TileSourceType=import(\"../source/Tile.js\").default]\r\n * @extends BaseTileLayer<TileSourceType, CanvasTileLayerRenderer>\r\n * @api\r\n */\r\nclass TileLayer extends BaseTileLayer {\r\n  /**\r\n   * @param {import(\"./BaseTile.js\").Options<TileSourceType>} [options] Tile layer options.\r\n   */\r\n  constructor(options) {\r\n    super(options);\r\n  }\r\n\r\n  /**\r\n   * @override\r\n   */\r\n  createRenderer() {\r\n    return new CanvasTileLayerRenderer(this, {\r\n      cacheSize: this.getCacheSize(),\r\n    });\r\n  }\r\n}\r\n\r\nexport default TileLayer;\r\n"],
  "mappings": "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",
  "names": ["xPos", "yPos", "width", "height", "lines", "size", "bandCount", "width", "height", "data", "offset", "len", "state", "DataTile_default", "Layer_default", "Tile_default", "DataTile_default", "dx", "dy", "i", "frameState", "Tile_default"]
}
